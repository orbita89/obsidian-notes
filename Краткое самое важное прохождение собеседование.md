-  Методология
    - Waterfall (Каскадная)(Водопадная) — линейная, последовательная модель разработки.
    - Agile (Гибкая) — итеративная методология, предполагающая частые изменения и адаптацию.
    - Scrum — фреймворк Agile с четкими ролями и спринтами для выполнения задач.
    - Kanban — визуальная система управления задачами с помощью доски для непрерывной доставки.
    - V-модель — расширенная каскадная модель, где каждая фаза разработки имеет свой этап тестирования.
    - Инкрементальная модель — разработка проходит поэтапно, каждый этап добавляет функционал, расширяя предыдущую версию системы.
    - Спиральная модель — комбинирует элементы каскадной и итеративной моделей, с акцентом на оценку рисков на каждой итерации (витке).
    - Основные принципы Scrum - Итеративность и инкрементаоьность
-  JSON and XML
    1. [JSON](https://ru.wikipedia.org/wiki/JSON) (JavaScript Object Notation) - простой формат обмена данными
    2. xml - расширяемый язык разметки. Используется для хранения и передачи данных. <?xml version="1.0" encoding="UTF-8"?> -можно указать версию и кодировку в начале.Атрибуты могут быть добавлены к тегам. Атрибуты определяются внутри начального тега и указываются как пары ключ="значение".
    3. Приемущества XML a) Читаемость человеком и машиной. Имеет чёткую структуру с открывающимми и закрвающими тэгамии, б) Гибкость и расширяемость, в) Поддержка схем и валидации (XSD) - можно легко провалидировать данные указать тип размер длину и т.д г) Поддержка метаданных
    4. Недостатки XML а) Требует большое пространства б) меньше производительность в) сложность г) избыточность д) трудность чтение и написании
    5. Основные правила для XML а)Один корневой элемент Весь документ должен быть заключен в один корневой элемент. б) Правильная структура: Элементы должны быть правильно вложены и закрыты. в)Использование кавычек Атрибуты должны быть заключены в двойные кавычки. г)Чувствительность к регистру Имена тегов и атрибутов чувствительны к регистру. д)Экранирование символов Все специальные символы должны быть экранированы. е)Пустые элементы Можно использовать самозакрывающиеся теги для пустых элементов. ё)Декларация XML Желательно начинать документ с декларации <?xml version="1.0" encoding="UTF-8"?>.
    6. Основные типы, которые могут быть представлены в JSON:а)Объекты б)Массив в)Строка г)Число д)Логическое значение 6) null
    7. Преимущества json а)Меньше объём и компактность по сравнение с XML - так как в xml слишком много тегов. б)Легкость в использовании. Для обработки программно — большинство языков программирования в)Парсинг обычно быстрый чем XML - так же иза обработки тегов г)Широкая поддержка в веб-разработке
    8. Недостатки json a)Отсутствие поддержки схем - это означает нужно полагаться на дополнительнные инструменты JSON Schema. б)Ограничность метаданных - это то что в XML можно указать атрибуты в json нельзя. в)Меньше гибкости для сложных документов.Причины: 1)Отсутсвие атрибутов 2)Сложные иерархии - XML лучше подходит для представление сложных иерархий данных 3)Нет явной структуры для документов с разными типами данных
    9. Основные правила формирования а)JSON:Корневой элемент — должен быть либо объектом {}, либо массивом [].б)Ключи — строки в двойных кавычках.в)Значения — могут быть строками, числами, объектами, массивами, булевыми значениями или null.в)Отсутствие комментариев — комментарии в JSON не допускаются.г)Без лишних запятых — после последнего элемента не должно быть запятых.
-  СУБД
    1. SQL (Structured Query Language) — это язык программирования, используемый для управления и манипулирования реляционными базами данных
    2. СУБД - система управление база данным(Реляционная(Mysql), Нереляционная(Mongo))
    3. Сущность и отношения - это таблица в базе данных. где каждая строка это объект, а столбцы это его характеристики
    4. Sql-команды подноможества a)DML - команда для работы с даннами. Управляет сожержимым таблиц, изменяя записи, но не изменяют структру таблиц б) DDL - команда для определение стрктурой даннами. Изменяют таблицы в)DCL - комадны для управлениям правами
    5. Целостностью данных a)Целность сущности(гарантирует что сущности имеют уникальные значения) б)целостность отношение(гарантирует что внешние ключи совпадают) в)Целность домена(гарантирует что данные соотвествует указанным тип данных) г) Целность пользователя д)Целность транзакций(ACID)
    6. DELETE and TRUNCATE Delete(DML)Удаляет(Данные) и TRUNCATE(DDL)Очищает(Данные,индексы,структуру)
    7. JOIN: LEFT RIGHT FULL
    8. Отношение один к одному, один ко многим, многим ко многим
    9. Кластеризованные индексы - Упорядочивает физические данные. может быть один
    10. Некластеризованные индексы - Индексы которые хранят указатели на данные в таблице, нужно для ускорение поиска по таблице
    11. Индексы(Primary key - уникальный идентификатор строки, UNIQUE INDEX - поля которое должно быть уникальным, CLUSTERED INDEX - часто используеться для сортировки, NON-CLUSTERED - часто выполняемые запросы на поиск, FULLTEXT - поиск по тексту, SPATIAL INDEX - геоданные, BITMAP INDEX - колонки с маллым числом, составной индекс - такой индекс может содержать более одного столбца)
    12. Таблица не имеющая кластеризованного индекса называеться кучей
    13. Советы при проектирование таблиц. Для таблиц которые часто обновляются используйте как можно меньше индексов. Если таблица содержит большое количество данных, но их изменения незначительны, тогда используйте столько индексов, сколько необходимо для улучшение производительности ваших запросов. Однако хорошо подумайте перед использованием индексов на небольших таблицах, т.к. возможно использование поиска по индексу может занять больше времени, нежели простое сканирование всех строк. Для кластеризованных индексов старайтесь использовать настолько короткие поля насколько это возможно. Наилучшим образом будет применение кластеризованного индекса на столбцах с уникальными значениями и не позволяющими использовать NULL. Вот почему первичный ключ часто используется как кластеризованный индекс. Уникальность значений в столбце влияет на производительность индекса. В общем случае, чем больше у вас дубликатов в столбце, тем хуже работает индекс. С другой стороны, чем больше уникальных значения, тем выше работоспособность индекса. Когда возможно используйте уникальный индекс. Для составного индекса возьмите во внимание порядок столбцов в индексе. Столбцы, которые используются в выражениях _WHERE_ (к примеру, _WHERE FirstName = 'Charlie'_) должны быть в индексе первыми. Последующие столбцы должны быть перечислены с учетом уникальности их значений (столбцы с самым высоким количеством уникальных значений идут первыми). Также можно указать индекс на вычисляемых столбцах, если они соответствуют некоторым требованиям. К примеру, выражение которые используются для получения значения столбца, должны быть детерминистическими (всегда возвращать один и тот же результат для заданного набора входных параметров).
    14. Вопросы по индекс [Вопросы по индексам](https://www.notion.so/18a536c9c788802eac8fed89e3974727?pvs=21)
    15. Нормализация — процесс организации данных, цель которого избежать дублирования и избыточности. Преимущества а) Лучшая организация базы данных б) Больше таблиц с небольшими строками в) Эффективный доступ к данным г) Большая гибкость для запросов д) Быстрый поиск информации е) Позволяет легко модифицировать ё) Проще реализовать безопасность данных ж) Сокращение избыточных и дублирующихся данных з)Более компактная база данных к) Обеспечивает согласованность данных после внесения изменений
    16. Нормальная форма 1NF - в каждой ячейке(строке) должго быть одно значение, каждая строка должна иметь уникальный идентификатор (первичный ключ). 2NF Вторая нормальная форма . Не должно быть такое что бы от первичного ключа зависили поля которые не относиться к таблице это привидет к дубликации вообщем нужно создавать так что относиться к текущей таблицы то и добавлять. 3NF И все неключевые атрибуты напрямую зависят только от первичного ключа,а не от других неключевых атрибутов.
    17. Способы проектирование базы данных а) Нормализация б) Денормализация в) Проектирование на основе использования реальных запросов г)Проектирование шаблонами (Звездная схема, Снежинка, проектирование с учетом индексов)
    18. Какие операторы доступны в sql а) Арифметические б) логические г) сравнение
    19. Подзапросы а) Select б) Where некоррилрованный и коррелированный в) Фром г) хевинг д) с операторами in, exists, any, all е) сколярный подзапрос - возращает одно значение
    20. Оконная функция – это тип функции в SQL, которая выполняет вычисления для набора строк в определенном “окне” или диапазоне. Она используется для решения сложных аналитических задач, которые не могут быть легко решены с помощью простых агрегатных функций.
    21. union - объединение таблиц по какому-нибудь значению выбирает только уникальные значения
    22. union all - объединяет таблицу по какому-нибудь значению выбирает все значения
    23. profiling — это процесс сбора и анализа информации о выполняемых SQL-запросах, чтобы определить.
    24. profiling. triggers. deadlocks
-  Linux
	1. Ядра
-  Основа сетей (архитектуры и подходы)
	1. Типы сетей lan - локальная сеть,  wan - глобальная, nat - которая позволяет из локального переходить в глобальную
	2. CDN — это сеть серверов, расположенных по всему миру, которые кэшируют и раздают статический контент (HTML, CSS, JS, изображения, видео и т.д.) максимально близко к пользователю.
	3. IPv4 — 32 бита, адрес вида 192.168.0.1, около 4,3 млрд адресов.  IPv6 — 128 бит, адрес вида `2001:0db8::1`, практически неограниченное число адресов.
	4. Подсеть (subnet) — это логически выделенная часть IP-сети, которая помогает эффективно организовать, управлять и ограничивать сетевой трафик внутри более крупной сети.
	5. TCP(Transmission control protocol) - это надежный протокол он отличается надежностью(веб-сайтов, электронной почты) от UDP(USER Datagram Protocol) - быстрый, но ненадёжный пакеты могут теряться или приходить не по порядку
	6. Большая инфа по протоколам.
    - Прикладной уровень - Обеспечивает взаимодействие с пользователем и приложениями.
        
        - HTTP (HyperText Transfer Protocol) — передача веб-страниц (порт 80).
        - HTTPS (HTTP Secure) — защищенная версия HTTP с TLS/SSL - это сертификаты тройное рука пожатия только более сложной форме(порт 443).
        - FTP (File Transfer Protocol) — передача файлов между устройствами (порты 20, 21).
        - SFTP (Secure FTP) — безопасная передача файлов по SSH (порт 22).
        - SMTP (Simple Mail Transfer Protocol) — отправка электронной почты (порт 25).
        - IMAP (Internet Message Access Protocol) — получение почты с сервера, оставляя копию (порт 143).
        - POP3 (Post Office Protocol v3) — получение почты с удалением с сервера (порт 110).
        - DNS (Domain Name System) — преобразование доменов из IP-адреса (порт 53).
        - DHCP (Dynamic Host Configuration Protocol) — автоматическая выдача IP-адресов (порты 67, 68).
        - Telnet — удаленное управление устройствами без шифрования (порт 23).
        - SSH (Secure Shell) — безопасное удаленное управление (порт 22).
    - Уровень представления - который отвечает за обработку, преобразование и шифрование данных перед их передачей на прикладной уровень.
        
        1. Форматирование и кодирование данных
            - Преобразует данные в формат, который понимает приложение (например, JSON, XML, ASCII, Unicode).
        2. Сжатие данных
            - Уменьшает размер данных для ускорения передачи (например, ZIP, GZIP).
        3. Шифрование и безопасность
            - Защищает данные от несанкционированного доступа (например, SSL/TLS).
        
        SSL/TLS - Шифрование данных в интернете (используется в HTTPS, VPN)|
        JPEG, PNG, GIF - Кодирование изображений|
        MP3, AAC, WAV - Кодирование аудио|
        |MPEG, H.264 - Кодирование видео|
        |ASCII, Unicode - Кодировка символов|
        |JSON, XML - Форматирование данных для веб-приложений|
        
    - Сеансовый уровень - Сеансовый уровень (Session Layer) — это 5-й уровень модели OSI, который отвечает за установку, поддержку и завершение соединений (сеансов) между приложениями.
        
        Основные функции сеансового уровня:
        
        1. Управление сеансами
            
            - Устанавливает, поддерживает и завершает соединения между клиентом и сервером.
        2. Синхронизация данных
            
            - Разбивает поток данных на контрольные точки, чтобы можно было восстановить передачу в случае сбоя.
        3. Контроль доступа
            
            - Обеспечивает безопасность соединения (например, аутентификацию пользователей).
            
            Примеры протоколов сеансового уровня:
            
            |Протокол|Назначение|
            |---|---|
            |RPC (Remote Procedure Call)|Удалённый вызов процедур между клиентом и сервером|
            |NetBIOS|Подключение и взаимодействие компьютеров в локальной сети|
            |PPTP (Point-to-Point Tunneling Protocol)|Создание VPN-туннелей|
            |SMPP (Short Message Peer-to-Peer Protocol)|Передача SMS между серверами|
            |RTCP (Real-Time Transport Control Protocol)|Управление потоковым аудио/видео|
            |SIP (Session Initiation Protocol)|Установление голосовых и видеозвонков (например, в VoIP)|
            
    - Транспортный уровень - это 4-й уровень модели OSI, который отвечает за передачу данных между устройствами и обеспечивает надежность, контроль ошибок и сегментацию.
        
         Основные функции транспортного уровня:
        
        1. Разбиение данных на сегменты
            
            - Данные делятся на пакеты, которые передаются по сети.
        2. Контроль целостности
            
            - Проверка ошибок с помощью контрольных сумм и подтверждение получения данных.
        3. Обеспечение надежности передачи
            
            - Гарантированная или быстрая доставка в зависимости от протокола.
        4. Управление потоком данных
            
            - Контроль скорости передачи, чтобы избежать перегрузки сети.
        5. Мультиплексирование
            
            - Одновременно поддерживает несколько соединений (например, загрузка нескольких вкладок в браузере).
            
            |Протокол|Характеристики|Где используется?|
            |---|---|---|
            |TCP (Transmission Control Protocol) - Надежный, с контролем ошибок, гарантирует порядок пакетов|Веб (HTTP/HTTPS), Email (SMTP, IMAP, POP3), FTP|
            |UDP (User Datagram Protocol) - Быстрый, без гарантии доставки, без контроля порядка|Видео- и аудиостриминг (VoIP, Zoom, YouTube), игры|
            |SCTP (Stream Control Transmission Protocol)|Совмещает надежность TCP и скорость UDP, передает несколько потоков данных|IP-телефония, сигнальные протоколы|
            |DCCP (Datagram Congestion Control Protocol - Контролирует перегрузку сети, но без гарантий доставки|Потоковое видео, IPTV|
            |QUIC (Quick UDP Internet Connections)|Работает поверх UDP, но с надежностью TCP, поддерживает мультиплексирование, встроенное шифрование и быстрый коннект|HTTP/3, Google Chrome, YouTube, Cloudflare, онлайн-игры|
            
    - Сетевой уровень - это 3-й уровень модели OSI, который отвечает за маршрутизацию, логическую адресацию и доставку пакетов данных между устройствами в разных сетях.
        
        Основные функции сетевого уровня:
        
        1. Маршрутизация
            - Определяет оптимальный путь для передачи данных от отправителя к получателю.
        2. Логическая адресация
            - Использует IP-адреса для идентификации устройств в сети.
        3. Фрагментация и сборка пакетов
            - Делит большие сообщения на более мелкие пакеты и собирает их на принимающей стороне.
        4. Обнаружение и исправление ошибок
            - Проверяет целостность пакетов (но не гарантирует их исправление, этим занимается транспортный уровень).
        
	     Примеры протоколов сетевого уровня:
        
        IP (Internet Protocol) - Основной протокол сетевого уровня, маршрутизирует пакеты данных|Интернет, локальные сети
        IPv4 - 32-битные IP-адреса, широко используется, но постепенно заменяется IPv6|Интернет, корпоративные сети
        IPv6 - 128-битные адреса, больше возможностей и безопасности|Будущее Интернета, мобильные сети|
        ICMP (Internet Control Message Protocol - Обмен служебными сообщениями (ping, ошибки сети)|Диагностика сети (ping, traceroute)|
        ARP (Address Resolution Protocol - Преобразует IP-адрес в MAC-адрес|Локальные сети (Ethernet, Wi-Fi)|
        RARP (Reverse Address Resolution Protocol) - Определяет IP-адрес по MAC-адресу|Старые сетевые устройства|
        OSPF (Open Shortest Path First) - Протокол динамической маршрутизации, ищет кратчайший путь|Маршрутизация в больших сетях|
        BGP (Border Gateway Protocol) - Управляет маршрутизацией между автономными системами (ISP)|Глобальный интернет, провайдеры|
        NAT (Network Address Translation) - Позволяет нескольким устройствам использовать один внешний IP-адрес|Домашние роутеры, корпоративные сети|
        
    - Канальный уровень - это 2-й уровень модели OSI, который отвечает за надежную передачу данных между устройствами в пределах одной сети. Он обеспечивает контроль доступа к физической среде и формирование фреймов для передачи.
        
         Основные функции канального уровня:
        
        1. Формирование фреймов
            - Делит данные на фреймы, добавляя заголовки с адресами и контрольной суммой.
        2. Контроль доступа к среде
            - Управляет доступом устройств к общей передающей среде (например, Ethernet, Wi-Fi).
        3. Обнаружение и коррекция ошибок
            - Проверяет целостность передаваемых данных, используя контрольные суммы и другие механизмы.
        4. Управление потоком данных
            - Контролирует скорость передачи данных, чтобы предотвратить перегрузки.
        5. Адресация
            - Использует MAC-адреса для идентификации устройств в локальной сети.
        
        Примеры протоколов канального уровня:
    
        Ethernet - Наиболее распространенный стандарт передачи данных по проводным сетям, использует MAC-адреса|Локальные сети (LAN), проводные соединения|
        Wi-Fi (IEEE 802.11) - Стандарт для беспроводных сетей, использует аналогичные Ethernet принципы, но для радиочастот|Беспроводные сети (Wi-Fi), мобильные устройства|
        PPP (Point-to-Point Protocol) - Протокол канала передачи данных, используется для точка-точка соединений|VPN, модемы, DSL-соединения|
        HDLC (High-Level Data Link Control) - Стандарт для надежной передачи данных по каналам связи|ISDN, линия связи между маршрутизаторами|
        Frame Relay - Протокол для передачи данных с использованием виртуальных каналов|Мобильные сети, выделенные линии связи|
        ATM (Asynchronous Transfer Mode) Используется для передачи данных в режиме постоянного потока с высокой скоростью|Высокоскоростные сети, мультимедийные приложения|
        ARQ (Automatic Repeat Request) Используется для повторной передачи пакетов в случае ошибок|Беспроводные и проводные сети, беспроводные устройства|
        FDDI (Fiber Distributed Data Interface) Стандарт для высокоскоростных сетей на основе оптоволокна|Высокоскоростные оптоволоконные сети|
        
    - Физический уровень (Physical Layer) — это 1-й уровень модели OSI, который отвечает за физическую передачу данных по каналу связи. Он управляет преобразованием битов в электрические сигналы, световые импульсы или радиоволны, в зависимости от типа канала передачи. Bluetooth, DSL (Digital Subscriber Line), Fiber Optic (Оптоволоконная передача), RS-232, USB (Universal Serial Bus), ISDN (Integrated Services Digital Network)
        
    - Пример что произходит когда открываеться страница
        
        1. Ввод URL в браузере
        Когда вы вводите URL в адресную строку браузера, браузер начинает процесс запроса этой веб-страницы.
        
        - Прикладной уровень (Application Layer):Браузер формирует HTTP(S) запрос. Так как протокол HTTPS используется, он также инициирует создание защищённого соединения через TLS/SSL. На этом этапе браузер собирает все необходимые данные для подключения к серверу (например, адрес веб-сайта).
        
         2. Проверка DNS
    
        Прежде чем браузер отправит запрос на сервер, он должен преобразовать доменное имя ([www.example.com](http://www.example.com/)) в IP-адрес, так как сети и маршрутизаторы используют IP-адреса для передачи данных.
        
        - Прикладной уровень (Application Layer):
            
            Процесс преобразования доменного имени в IP-адрес выполняется с использованием DNS (Domain Name System). Браузер отправляет запрос на DNS-сервер для получения IP-адреса.
            
            Если в кеше браузера или операционной системы есть сохранённый IP-адрес для этого домена, браузер использует его.
            Если нет, браузер отправляет запрос к DNS-серверу для получения IP-адреса.
        
        
        3. Установка TCP-соединения (Тройное рукопожатие TCP)
    
        Браузер теперь знает IP-адрес сервера (например, 93.184.216.34 для [example.com](http://example.com)) и может начать установку соединения с сервером.
        
        - Транспортный уровень (Transport Layer):
            
            В случае использования TCP (что характерно для HTTPS), устанавливается соединение между клиентом и сервером с использованием тройного рукопожатия.
            
            1. SYN: Клиент отправляет пакет с флагом SYN, который сигнализирует серверу о намерении установить соединение.
            2. SYN-ACK: Сервер отвечает пакетом с флагом SYN-ACK, подтверждая готовность установить соединение.
            3. ACK: Клиент подтверждает соединение, отправляя пакет с флагом ACK.
            
            После этих шагов устанавливается соединение, и клиент может начать передавать  данные.
            
        
        
        4. Шифрование данных (если используется HTTPS)
        
        Если сайт использует HTTPS, то на этом этапе происходит установление защищённого соединения через TLS (Transport Layer Security).
        
        - Представление (Presentation Layer):На этом уровне происходит создание защищённого канала для передачи данных между клиентом и сервером.
            1. TLS Handshake: Браузер и сервер обменяются сертификатами и согласуют параметры шифрования. Сервер передает свой публичный ключ, а клиент генерирует общий секретный ключ.
            2. Данные, которые передаются между клиентом и сервером, будут зашифрованы с использованием согласованного ключа.
        
         5. Отправка HTTP-запроса на сервер
                
        Теперь, когда соединение установлено и защищено (если используется HTTPS), браузер отправляет HTTP-запрос к серверу для получения веб-страницы.
        
        - Прикладной уровень (Application Layer):Формируется HTTP-запрос с необходимой информацией. Например, для запроса главной страницы веб-сайта это может быть запрос вида:Запрос включает:
            
        
        6. Маршрутизация запроса через сеть
        
        Запрос от клиента отправляется по сети к серверу через маршрутизаторы, которые работают на сетевом уровне.
        
        - Сетевой уровень (Network Layer):Запрос инкапсулируется в IP-пакет, который содержит:IP-пакет маршрутизируется через несколько сетевых устройств (маршрутизаторов), которые определяют лучший путь для передачи пакета от клиента к серверу.
		    IP-адрес клиента (IP-адрес вашего устройства).
            IP-адрес сервера (например, 93.184.216.34).
        
         7. Канальный уровень (Data Link Layer)
        
        Когда IP-пакет достигает локальной сети или непосредственно сервера, данные инкапсулируются в фрейм канала передачи данных.
        
        - Канальный уровень (Data Link Layer):
            
            Фрейм добавляет информацию о MAC-адресах (физические адреса устройств), что необходимо для доставки данных на уровне локальной сети (например, Ethernet или Wi-Fi).
            
            Данные передаются через физическое соединение, будь то кабель (Ethernet) или беспроводное соединение (Wi-Fi).
            
        
        ---
        
        8. Физический уровень (Physical Layer)
        
        После инкапсуляции данных в фреймы канала, данные передаются через физический носитель.
        
        - Физический уровень (Physical Layer):Биты данных (представляющие фрейм) преобразуются в физические сигналы, которые передаются по сети:
            - Если это Ethernet, то данные передаются через электрические импульсы по проводам.
            - Если это Wi-Fi, данные передаются через радиоволны.
        
        ---
        
         9. Сервер обрабатывает запрос и отправляет ответ
        
        Теперь запрос достиг сервера. Сервер обрабатывает запрос и генерирует ответ.
        
        - Прикладной уровень (Application Layer):Сервер принимает запрос, обрабатывает его и формирует ответ в виде HTML-страницы (или других ресурсов). Этот ответ может включать HTML, CSS, JavaScript, изображения и другие данные.
        
        ---
        
        10. Ответ проходит по всем уровням и возвращается в браузер
        
        Ответ сервера передается обратно через все уровни OSI (физический, канальный, сетевой, транспортный, сеансовый, представление и прикладной), но теперь в обратном порядке.
        
        - Транспортный уровень (Transport Layer):Ответ инкапсулируется в TCP-сегменты, и данные отправляются обратно через установившееся соединение.
        - Сетевой уровень (Network Layer):Ответ инкапсулируется в IP-пакеты.
        - Канальный уровень (Data Link Layer) и Физический уровень (Physical Layer):Данные передаются по сети обратно к вашему устройству.
        
        ---
        
         11. Декодирование и отображение страницы в браузере
        
        Когда данные возвращаются в браузер, они проходят через каждый уровень в обратном порядке, пока не достигнут прикладного уровня, где браузер обрабатывает HTML-контент и отображает страницу пользователю.
        
        - Прикладной уровень (Application Layer):Браузер получает ответ от сервера (например, HTML-контент страницы) и обрабатывает его. Он загружает CSS и JavaScript, чтобы отобразить страницу.
        - Представление (Presentation Layer):Если данные были зашифрованы, они теперь расшифровываются.
        - Сеансовый уровень (Session Layer):Устанавливается сессия для общения с сервером, и, если нужно, используются куки.
	1. VLAN - это виртуальная локальная сеть, которая позволяет разделить физическую сеть на несколько логических подсетей, что дает возможность изолировать трафик между различными группами устройств, находящихся на одном физическом сегменте сети.
	2. MAC-адрес (Media Access Control address) - это уникальный идентификатор, назначаемый каждому сетевому устройству на физическом уровне. Он используется для определения и адресации устройств в сети.
	3. Клиент-серверная архитектура — это модель взаимодействия между двумя сторонами: клиентом (программой, инициирующей запрос) и сервером (программой, обрабатывающей запрос и отправляющей ответ)
	4. Основные виды архитектуры клиент-сервер. Одноуровневая архитектура (1-Tier) - это тип архитектуры программного обеспечения, в которой все компоненты системы (данные, логика и интерфейс) находятся в одном и том же приложении или среде. например базы данных. Двухуровневая архитектура (2-Tier) - Эта модель разделяет приложение на два независимых компонента клиент и сервер Трехуровневая архитектура (3-Tier) - это архитектурная модель, которая разделяет приложение на три независимых уровня: пользовательский интерфейс (представление), бизнес-логика и уровень данных.
	5. Микросервисная архитектура — это способ разработки программного обеспечения, где приложения состоят из небольших, независимых компонентов, называемых микросервисами. Каждый из которых реализует одну четкую бизнес-функцию и взамодействует с другими сервесами через легковесный протоколы, как правило через REST API, gRPC, сообщение (RabbitMQ, Kafka) Характеристики микросервиса а)Мультикомпонентные(разделение на множество компонентов) б)Созданы для бизнеса в) Простая маршрутизация() г)Децентрализованные(Иметь каждый микросервис может иметь свои технология) д) Отказоустойчивые
	6. Rest - это архитектурный стиль взаимодействия между клиентом и сервером по протоколу HTTP, при котором все операции с ресурсами (данными) выполняются через стандартные HTTP-методы. Основные принципы REST a)Клиент–серверная архитектура б)Без сохранения состояния (stateless)  - Каждый HTTP-запрос содержит всю необходимую информацию для обработки. Сервер не хранит информацию о предыдущих взаимодействиях. в) Кэшируемость - Ответы сервера могут кэшироваться, чтобы снизить нагрузку и ускорить отклик. г) Единый интерфейс д) Идентификация ресурсов через URI е)Представление ресурса. Ответ сервера — это представление ресурса.
	7. gRPC — это современный, высокопроизводительный фреймворк удалённых вызовов процедур (RPC) - это модель взаимодействий, разработанный Google. Он основан на HTTP/2, использует Protocol Buffers (protobuf) как язык описания контрактов и обеспечивает строго типизированное, эффективное взаимодействие между распределёнными системами и микросервисами. клиент вызывает методы удалённого сервиса напрямую, как если бы они были локальными. Инструмент для высокоэффективного взаимодействия между машинамми.
	8. GraphQL - это язык запросов к API и среда выполнения этих запросов, он позволяет клиенту точно указывать, какие данные ему нужны, вы делаете это в рамках одного запроса, с любой нужной глубиной вложенности и с минимальной нагрузкой.
	9. SOAP (Simple Object Access Protocol) — это протокол для обмена структурированными сообщениями между приложениями через сеть. Он основан на XML и обычно используется для вызова веб-сервисов. SOAP работает поверх различных транспортных протоколов (например, HTTP, SMTP) и поддерживает сложные механизмы безопасности и надежности передачи данных.
	10. HTTP (HyperText Transfer Protocol) — это протокол прикладного уровня, предназначенный для передачи данных в виде запросов и ответов. Используется в клиент-серверной архитектуре. Основные методы HTTP-методы. основные версии которые щас используют 1.1 формат текст протокл tcp не подерживает(Сжатие загаловков, многопоточность, повторное использование, подержка Server push) версия 2 и 3 все это подерживается только отличие между 2 и 3 версии используют разные протоколы 2 - tcp 3 - quic
	11. GET — это идемпотентный и безопасный HTTP-метод, предназначенный исключительно для запроса (чтения) ресурса с сервера. Он не должен изменять состояние сервера, а только запрашивает данные по заданному URL. Главный кандидат для кэширование.Максимальная длина url 2000 символов. По идее нельзя передовать тело но возможно
	12. POST — это HTTP-метод, предназначенный для отправки данных на сервер. В отличие от GET, метод `POST` может изменять состояние сервера (например, создавать ресурсы, инициировать действия и т.д.). Post влияеть на систему он может по этому не является безопасным для системы.
	13. PUT — это HTTP-метод, который используется для полной замены ресурса по указанному URL. В REST API `PUT` обычно применяется для обновления ресурса, но при этом может также использоваться для создания ресурса, если он ещё не существует (идемпотентное создание).
	14.  PATCH — это HTTP-метод, используемый для частичного обновления ресурса. В отличие от PUT, который полностью заменяет объект, `PATCH` изменяет только указанные поля, оставляя остальные без изменений.
	15. DELETE — это метод, предназначенный для удаления существующего ресурса. После выполнения запроса по соответствующему URI, ресурс должен быть удалён или помечен как удалённый.Являеться идемпотентым.
	16. HEAD - как GET только возвращает только заголовки
	17. OPTIONS - Возвращает список поддерживаемых методов для указанного ресурса.
	18. TRACE - Диагностический метод. Возвращает полученный сервером запрос.
	19. CONNECT - Используется для установления туннеля.
	20. Идемпотентность запроса — это состояние системы изменится только один раз при многократном вызове. пример: GET, PUT, DELETE.
	21. Классы кодом состояние. 100 - информационные. 200 успешность. 300 перенаправления. 400 ошибка клиента. 500 ошибка сервера.
	22. HTTP-заголовки — фундаментальная часть протокола, обеспечивающая передачу метаданных и управление поведением клиента и сервера. Понимание их принципов критично для разработки, отладки и безопасности веб-приложений.
	23. Авторизация.Базовая авторизация логин пароль.При регистрации пароль хешируеться. Авторизация токеном (JWT) - основан на криптографии и подписи, не требует хранить сесси на сервере,Access Token очень короткий поэтому для этого нужно использовать refresh  token - он нужен для получение нового access token. cлишком длинный — небезопасно. Слишком короткий — неудобно. И для этого используем refresh token. Авторизация при помощью API KEY - это уникальный идентификатор (обычно строка), который выдаётся клиенту (например, приложению, сервису или пользователю) для доступа к API это способ простой можно быстро внедрить, нет привязки к пользователю, не сроков действий. OAuth 2.0 - регистрация (авторизация) без пароля хорошо работает со стороними сервесами(telegram, vk, google). Session-Based Authentication - стандартная авторизация на сессии.  Mutual TLS (mTLS) - очень безопансная авторизация использует сертификаты для авторизации.
	24. Сертификаты в интернете — это цифровые документы, которые подтверждают подлинность сайта, сервиса или пользователя. Они являются ключевым элементом шифрования и безопасности в интернете.
	25. Веб Сокеты - нужно для отображение страницы без перезагрузки. Это альтернатива традиционному HTTP-запросу, где соединение открывается и закрывается каждый раз заново.
	26. Веб хук. Принцип работы вебхуков (Webhooks) базируется на том, чтобы реагировать на события в режиме реального времени и передаче данных с сервера получателю без активных запросов со стороны клиента.
	27. Cookie (HTTP cookie) — это небольшой фрагмент данных, который сохраняется браузером на стороне клиента и отправляется с каждым HTTP-запросом к тому же домену. Куки бывают постоянные, сессионые, сторонние, зомби. супер куки устанавливаются и храняться не как стандартные куки. их будет сложнее удалить или изминить
	28. Кэш - это временное хранилище данных, предназначенное для ускорения повторного доступа к часто запрашиваемой информации. Система делает запрос на кэш если кэш найден то берём их это называется кэш-хитом если данных нет то это будет называться кэш-промах. Способы кэширования клиент http- заголовки. CDN и прокси-сервера пример nginx. Серверное кэширование (бэкенд) пример Redis. Кэш на уровне приложений и API используют фреймворки лара симфони.
	29. Nginx  — это высокопроизводительный веб-сервер и обратный прокси-сервер, также поддерживающий почтовый проксирование и балансировку нагрузки. Он ориентирован на высокую масштабируемость, низкое потребление ресурсов и высокую пропускную способность. однопоточную событийно-ориентированную архитектуру. так же есть Апач - только более старые и отлчиаеть подходами менее производительнее. 
	30. Рендеринг это процесс генерации изображения, визуализации графики или формирования данных для их последующего отображения пользователю. Варианты рендеринга. Предсгенерированный HTML (Static Rendering) готовый html храниться на сервере подходит для статических сайтов. SSR (Server-Side Rendering) - HTML не хранится как файл. Он генерируется на лету при каждом запросе подходит для динамических сайтов. CSR (Client-Side Rendering) - в  этом случае сервер не отправляет HTML-контент (только пустой html) весь html генерируеться в браузере при помощи. Гибрид SSR + CSR (универсальный рендеринг) - гибрид двух версия когда сервер отдаёт готовы шаблон и когда страница в вырисовываеться на стороне клиента с помощью гидраций
	31. Логирование - это процесс систематической записи событий. Это ключевой инструмент для отладки, мониторинга, безопасности и аудита. Источник логов приложение, веб-сервер, ос, субд. уровень логирование debug, info, notice, warning, error, critical, alert
-  Kubernetes
	1. Kubernetes(кубик) - управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров. нужно что бы масштабировать и запускать контейнеры сразу на большом количестве хостов а также  балансировать нагрузку.
	2. Кластер Kubernetes — это структурированная система из нескольких машин (нод), которые объединяются в единый комплекс для развёртывания, масштабирования и управления контейнеризованными приложениями. Он представляет собой набор ресурсов (серверов, сетей, хранилищ). Архитектура кластера Control Plane (Управляющая плоскость).Отвечает за управление кластером:принимает команды (kubectl), планирует, где запускать приложения, следит за состоянием кластера.
	3. Нода — это рабочая машина, на которой непосредственно работают ваши контейнеры (через поды).  Master node - отвечает за управление кластером. Worker node - запускаються контейнеры приложений
	4. Pod — это один или несколько контейнеров, запущенных вместе на одной ноде, которые делят между собой ресурсы и сеть. например nginx
	5. Service — это абстракция, которая объединяет группу Pod’ов по метке (label) и предоставляет для них стабильный IP-адрес и DNS-имя для взаимодействия.
	6. Volume — это абстракция над хранилищем, которое монтируется в контейнер как папка. Нужно для устойчивости - данные не теряются при перезапуске контейнера, общий доступ - Несколько контейнеров одного Pod’а используют общий том.
	7. Labels -  В Kubernetes labels (метки) — это один из ключевых механизмов организации, поиска и управления ресурсами в кластере.
-  Docker and ci/cd
	1. Docker — это платформа, позволяющая запускать приложения в изолированных контейнерах. Контейнеры обеспечивают приложениям стабильную и предсказуемую среду, где бы они ни запускались.
	2. Контейнеры — это легковесные, изолированные среды выполнения, внутри которых работают приложения. В отличие от виртуальных машин, контейнеры используют общее ядро операционной системы, что делает их менее затратными с точки зрения ресурсов. Это позволяет запускать больше контейнеров на одном сервере. а вертуальные машины работают так каждая ос использует свое ядро.
	3. Образ Docker (Docker Image) — это шаблон для создания контейнеров. Он представляет собой упакованное, неизменяемое и многослойное хранилище всех данных, необходимых для запуска приложения: самого приложения, зависимостей, библиотек, системных файлов и инструкций запуска. Docker Image — это фундамент для запуска контейнера. Он определяет что находится в контейнере и как он должен работать, описывает с помощью dockerfile. Это неизменяемый, многослойный шаблон, обеспечивающий воспроизводимость и переносимость.
	4. При первом запуске докера провиряем наличия образа логально если нет то скачиваем его docker hub создает контейнер запускает указанную в образе команду.
	5. Docker сети - Docker использует абстракции сетей для организации взаимодействия между контейнерами, хостом и внешним миром. Сети позволяют. Изолировать контейнеры. Обеспечить маршрутизацию. Настраивать DNS-имена. Управлять доступом. bridge - по умолчанию для одиночных контейнеров. host - использование сетевого стека хост, контейнер не имеет собственного сетевого пространства — он использует интерфейсы хоста напрямую. overlay — для кластеров организация сети между контейнерами. none - отключенная сеть контейнер полностью изолирован.
	6. Docker Volumes — это стандартный механизм для постоянного хранения данных контейнеров, независимый от жизненного цикла самого контейнера. представляющие собой директорию. не зависит от контейнера. может подключать к разным контейнерам поддержимает бэкапы и миграцию.
	7. dockerfile и docker-compose. dockerfile сборка образа docker-compose - запуск одного или нескольких контейнеров в одном файле позволяет автоматизировать этот процесс.
	8. ci/cd  ci - непрерывнаяя интеграция - это практика, регулярно вносение изменений в общий репозиторий. этапы build здесь произходит сборка проекта тестирование(юнит-тесты, линтер) проверяет на ошибки. поддерживает стабильность главной ветки. cd - это автоматическая доставка кода в staging или production, но с ручным потверждением
-  Kafka
	1. Apache Kafka – это распределенная потоковая платформа, позволяющая обрабатывать триллионы событий в день. Kafka гарантирует минимальные задержки, высокую пропускную способность, предоставляет отказоустойчивые конвейеры, работающие по принципу «публикация/подписка» и позволяет обрабатывать потоки событий как один из способов общение между микросервисами.Кластер Kafka позволяет изолировать консумеры и продюсеры друг от друга. Продюсер ничего не знает о консумерах при записи данных в брокер, а консумер ничего не знает о продюсере данных.
	2. Продюсеры (Producer) - Отправляет данные сообщение. 
	3. Консумер (Consumer) - Компонент, который читатет сообщения из патртиции
	4. Брокер в Kafka — это центральный компонент, обеспечивающий приём, хранение и передачу сообщений.
	5. кафка кластер - Совокупность брокеров Kafka, работающих совместно.
	6. Реплика - Механизм копирования партиций между брокерами для обеспечения отказоустойчивости.
	7. ZooKeeper или Kraft- Используется для координации брокеров основные действия (выбор контроллера брокера который будет управлять всеми изминениями создание топиков перераспределение партиций), Мониторинг живости брокеров , Управление конфигурацией, Обеспечение согласованности, 
	8. Консумер группа (Consumer Group) - Группа консюмеров, совместно читающих сообщения из топика; каждая партиция читается только одним участником группы.Цель — обеспечить параллельную обработку сообщений и устойчивое масштабирование.
	9.  Топик (Topic) - Логическая категория или имя канала, куда пишутся и откуда читаются сообщения.
	10. Партиция Partition - Физическое подразделение внутри топика, обеспечивающее параллелизм и масштабируемость.
	11. Оффсет (Offset) - Уникальный порядковый номер сообщения в партиции, указывающий на его позицию
	12. Процесс выполнения kafka - продюссеры выбирает топик, может отправить сообщение пачкой, принеудачи в сети отправить повторный запрос.Есть 3 основных способа доставки at most once(Допускает потери), at least once(Допускает дубликаты), exacity once(Строго одно) - более безопасное но большие задержки. Надежность доставки. указать acks 0 = будет отправлять сообщения в кафку не дожидаясь никаких подтверждениц записи. acks 1 = будет дожидаться ответа от брокера с лидерской партицией. acks -1 = будет дожидаться и с брокера и с реплик(так же более безопасней но требует больше накладных расходов). Проблемы с дубликатам в случаи сбои может решить идемпотентный решим.продюссер сериализует сообщение(json, avro,protobuf), определяет partition по ключу(если задан) а если не задан то выбирает по очереди, сообщение записывается в конец очереди партиции. Брокер сохраняет сообщение на диск. Разделение партиции между брокерами в кафке происходит по распределение нагрузки, отказоустойчивости,масштабируемости. Zookeeper и KRaft использовался для координации и управления Kafka-кластером они обеспечивают согласованное состяние, упрвление ролями, обнаружение сбоев, распределение нагрузки. Топики(Разделение на группы это и есть топик)  - в кафке разделены на партиции . партиции находятся на одном или нескольких брокеров, что позволяет кластеру  маштабироваться. партиции хранятся на локальных дисках брокеров и представлены набором лог-файлов -сегментов -определяется порядковым номером - оффсетом. лог файлы(оффсет) на диске устаревают по времени или размеру. настроить это можно глобально или индивидуально в каждом топике. Для отказоустойчивости партиции реплицируеться в другой брокер может так же настраивать глобально по умолчанию или для каждого топика отдельно реплики могут бать лидерами или фолловерами. Следующим этапом является чтение: консюмер запускает процесс poll, который регулярно отправляет запросы брокеру, получает доступные записи (если есть) и возвращает их как ConsumerRecords и читает оффсеты в порядке возрастания. В этот момент также обновляется внутренний таймер Heartbeat, подтверждающий активность консюмера. Если poll не вызывается вовремя, консюмер выходит из группы сам либо удаляется брокером. Это приводит к освобождению партиций, и Kafka инициирует ребалансировку.Первый участник консюмер-группы назначается лидером и отвечает за распределение партиций. Главное преимущество консюмер-группы — хранение оффсетов на стороне брокера, что обеспечивает устойчивость и восстановление. Также важно: в рамках одной группы одна партиция может быть назначена только одному консюмеру то есть одновременное чтение одной партиции несколькими участниками группы невозможно
- ElasticSearch
	-Анализатор - состоит из фильтра элемента, токенизатор, фильтр токенов
-  Основы ооп
	1. ООП(Объекто орентированое програмирование) - это парадигма программирование основана на объектах и их взаимодействия для построения программ. Объекты это строительнный блоки. Данные этого объекта называют атрибутами. Поведения объекта называют методом. Класс это чертеж(или шаблон), описывающие, какие поля или поведения будут в этом классе.Вызов класса это эксемпляр класса - что в дальнейшем будет объектом. Методе храниться очень часто храниться структурированный код.Плюсы ооп (Повышение читаемости и модульности,Повторное использование кода, Упрощённое тестирование). Минусы ооп(Сложность проектирования - неудачное архитектура классов может превести к избыточной сложности и запутаному коду, Переусложнения - иногда ООП используется там, где это не нужно (например, в простых скриптах), Низкая производительность - объектные модели иногда добавляют накладные расходы, Злоупотребление наследованием, Трудности с изменениями - иза повторного кода мы уменьшаем дублирование при изминения в одном месте может повлиять на многие компонетны.Частые проблемы. нарушение принципа единственной ответственности (SRP) - класс выполняет слишком много функций. нарушение инкапсуляции. Глубокое наследование. наследование вместо композиции. сильная связанность между классами - изменения в одном классе могут ломать другие.
	2. Описание отношений между классами. is-a(наследование) А является B. Собака является животным применяется при жесткой иерархии, когла объект действительно представляет тип базового класса. has-a(композиция) - это более гибкая альтернатива наследованию. А имеет объект B. Машина имеет двигатель. Это означает, что Car не является двигателем, а содержит его как компонент. uses-a(зависимость / внедрение)Класс A использует класс B. - это означает, что объект не владеет и не содержит, а просто временно использует объект для выполнения действия. can-do (реализация интерфейса) Класс A может выполнять поведение B.  Часто выражается через интерфейсы: A implements B.
	3. Инкапсуляция это скрытия внутреннего состояния объекта.основная цель скрыть детали реализации(1.повысит безопасность и надежность кода. 2.Разделение ответственности - это когда внешний код не знает, _как_ работает объект — он знает только, _что_ он делает (через интерфейс или публичные методы). 3.  Лёгкость изменения реализации. Плюсы инкапсуляции снижение связанности компонентов -внешние код работает только с публичными методами, не зная о внутренних деталях, защита данных от некорректного использования через (private и protected), гибкость в изменении реализации - можно изменить внутреннюю реализация без влияния на код. Повышает читаемости и упрощение отладки. Минусы инкапсуляции . Избыточность часто приходится писать множество геттеров/сетеров. снижение гибкости при чрезмерной закрытости. Анемичная модель — это класс без поведения, просто набор полей с get/set. Использование Инкапсуляция нужна, когда объект несёт поведение и ответственность, а не просто хранит данные. Не стоит применять инкапсуляцию формально — используйте там, где это приносит ценность: безопасность, контроль, стабильность интерфейса. Пример просто DTO для передачи данных, без логики можно использовать public readonly. Меньше if-else и switch-case, логика делегируется объектам.
	4. Полиморфизм способность объектов с одинаковым интерфейсом вести себя по-разному. Реализация через наследования родительского класса есть абстрактный метод который обезательнно нужно реализовать в подклассах но реализация в каждым методе может отличаться. Так же реализация через интерфессы идеальнно подходит для полиморфизма. Плюсы. Благодаря полиморфизму можно писать код, который работает с объектами через общий интерфейс или базовый класс и в частности абстрактный метод, не зная о конкретных реализациях.добавлять новые реализации (новые классы), не изменяя уже существующий код. Вызов метода не зависит от конкретного класса — различия скрыты за интерфейсом. Меньше if-else и switch-case, логика делегируется объектам. Позволяеи использовать DI и SOLID-принципы.В частности, Liskov Substitution Principle (LSP) и Open/Closed Principle (OCP). Минусы полиморфизма. Усложнение отладки. поведение размазано по разным классам, особенно если они в разных модулях.Подкласс может нарушить ожидаемое поведение базового типа (нарушение LSP). Проще говоря подкласс не должен изминять повидения, простой пример класс птица метод fly но не все птицы литают тоесть страус у наследоващий это тип так как являеться птицой ему придеться минять метод fly тем саммым поминяет повидение решение убрать зависимость от метода fly перенести этот метод в интерфейс тоесть делегировать в интерфейс. Сложность понимания кода. Избыточное проектирование. Частые ошибки. Нарушение подстановки Лисков (LSP) - без нарушения поведения. Слишком общие интерфейсы - Интерфейс описывает поведение, которое не нужно всем реализациям
	5. Наследование позволяет одному классу(дочерный или подкласс) у наследовать другой класс(родительский или суперкласс).Идея наследования состоит в том, чтобы переходить от общего к частному, выделяя общность. Это позволяет повторно использовать код и расширять его без дублирования.Плюсы. Уменьшает повторное испльзование кода. Упрощение структуры кода. Возможность использивоние полиморфизм. Изменения в родительском классе автоматически влияют на всех наследников. Можно добавлять или переопределять поведение без дублирования кода. Минусы наследования. Жесткая связанность подкласс зависит от реализации базового класса. Нарушение инкапсуляции подкласс получает доступ к внутренним данным родителя. Сложность сопровождения. Переопределение с неожиданным поведением. Множественное наследование недоступно. Частые ошибки. Нарушение принципа подстановки Лисков (LSP). Сложные иерархии (глубокое наследование). Жёсткая связность. Злоупотребление protected.Использование. Когда используеться наследование. Объекты находятся в жёсткой иерархической зависимости.Нужно переопределить поведение части системы. Есть общая неизменяемая логика для всех наследников. Когда не используеться наследование. Когда отношения "has-a" (объект включает другой объект). Когда просто нужно использовать только ради доступа к методам/свойствам базового класса. Когда поведение может изменяться во времени.
	6. Абстракция - Выделение общих характеристик и поведения объекта, скрывая детали реализации. Как абстракция работает вместе с полиморфизмом. Абстракция определяет контракт, а полиморфизм реализует поведение через него. То есть абстракция — основа, а полиморфизм — следствие её применения. Различие абстракции от инкапуляции. концепция инкапуляции будет отвичать только как защитить а абстракия передать. Минусы абстракции. Слишком абстрактно - сложно понять. Много мелких интерфесов - может привести к усложнению архитектуры. Сложность в отладки. Плюсы абстракции.  Пользователь работает с интерфейсом, не зная как устроено внутри, гибкость и расширяемость можно подменить реализацию без изменения кода клиента. подерживает полиморфизм. Принцип абстракции хорош, когда вы хотите отделить что делает от как делает. нужно обеспечить гибкость, модульность, расширяемость, проектирую систему под solid.
	7. Композиция —(отношение владеет полностью) это способ построения функциональности, при котором объект содержит другие объекты и делегирует им часть раболты, вместо того чтобы наследовать их поведение. Простыми словами в объект мы добавляем другие объекты(инницелизируем через конструктор). Гибкость поведение можно менять на лету, подменяя зависимости. Слабая связанность - не зависят от кPrincipleонкретное иерархии классов, лучшая тестируемость, поведение разделяеться на независимые компоненты, поведение можно повторно использовать в других классах.Минусы композиции. Больше кода - нужно явно описывать интерфейсы, усложнение конфигурации - в сложных системах, невозможность переопределить поведение “внутри” объекта в отличие от наследования, сложность отладки при глубокой вложенности. Когда применять. Когда объект — неотъемлемая часть другого. Когда жизненный цикл дочернего объекта полностью под контролем родителя. Когда дочерний объект не имеет смысла вне владельца.Когда требуется жёсткая связанность и автоматическое уничтожение дочерних объектов.
	8. Ассоциация —(знает о) это общее понятие связи между двумя классами. Один объект знает о другом и может взаимодействовать с ним, но не владеет им. Плюсы ассоциации Объекты могут быть связаны без жесткой иерархии наследование. Поведение распределяеться по разным классам, повторное использование объектов, ясное моделирование реальных отношений. Минусы и проблемы. Избыточное зависимотси между объектами(Один объект знает слишком много о других нарушаео SRP).Когда применять. Когда один объект временно взаимодействует с другим. Когда объекты не связаны логически, но нужно использовать функциональность друг друга. Когда жизненные циклы не зависят друг от друга.
	9. Агрегация — (имеет, но не владеет)это частный случай ассоциации, при котором один объект включает в себя другой как часть, но части могут существовать независимо от целого. Когда применять. Когда объект логически включает другие, но они могут жить отдельно.Когда один объект может входить в несколько агрегатов.Когда нужно логически объединить, но не управлять жизненным циклом.
	10. Конструктор - в основном нужен для инициализации объектов и атрибутов. передачи зависимостей, настройки начального состояния. Проблемы и подводные камни. Слишком много зависимостей - плохо мастабируется нарушает Single Responsibility Principle. Логика в конструкторе - конструктор должен только инициализировать объект. логику в отдельный метод. отсутствие значение по умолчанию.Конструктор в абстрактном классе или интерфейсе
	11. Методы доступа - private(Доступен только внутри самого класса.), public - открытый доступ(Доступ везде), prodected(Доступен только внутри самого класса и его потомков.)
	12. Абстрактный класс - должен имить хотя бы один абстрактный метод в отличие от интерфейса может иметь реализацию и используеться как базовый шаблон в отличие от интерфейса. Не может иметь экземпляров. Наличие частичной реализации (базовый шаблон) избежать дублирование кода. предоставить общее поведение для всез наследников, централизовать логику.
	13. Интерфейсы - это чистый контракт без реализации.Что такое совместим с разными классами. доступно множественное наследование. Задает набор методов которые должны быть реализованы. Обеспечить гибкость и совместимость между несвязанными  классами. т.е можно добалять в разные классы пример воробей летает и самолет летает воробей относиться к объкту птицы а самолет к техники.
	14. Trait — это механизм, позволяющий группировать методы и свойства, которые можно включать в несколько классов. Он не является ни классом, ни интерфейсом, и не может быть создан как объект.Он подходит для выделения общего поведения.Когда использовать. Нужно разделить общее поведениение без общего родителя. Поведение не зависит от стостояния класса. Требуется многократное влкючение повторяющейся логики.
	15. Enum - для хранения фиксированных значений чаще всего использовались константы. Однако enum (перечисления) — это значительно более мощный и выразительный механизм, чем простые константы. Какое преемущество по сравнение с константой. Типобезопасность. Проверка допустимых значний. Возможность добавлять методы и логику. Возможность использовать итерацию.
	16. final - final class — нельзя наследовать. final function — нельзя переопределить в потомках.
	17. Статический метод  это метод класса, который принадлежит самому классу, а не конкретному объекту. Он вызывается без создания экземпляра класса и не имеет доступа к $this, потому что $this указывает на текущий объект, а статический метод работает вне объекта. Нет объекта - нет ссылки на него. Особенности. Можно использовать self, static, parent внутри класса. Поддерживает наследование. можно переопределять в потомках. Часто применяется как утилита, Вспомогательные функции и фабрики. Когда использовать статический метод. метод не зависит от сосояния объекта.Метод часть общего поведения класса. метод реализует статическое апи. Когда не используют статический метод. Метод работает с внутренним состоянии объекта. Частые оишбки и проблемы. Злоупотребление static. заменяют все сервисы на статические методы → нарушается инкапсуляция. Статические методы - это скрытая глобальная зависимость  в любом месте программы жестко связвает ваш код с конкретной реализацией. Когда лучше использовать статический метод. 1. Метод чистый, не имеет состояния - не модифицирует глобальные переменные, static-поля, не изменяет состояние программы. 2. Не влияет на другие объекты. (Такие методы никак не «аффектят» (не влияют) друг друга). 3. Вы можете вызывать его из любого места кода — он не зависит от состояния объекта.
	18. Статический атрибут - Принадлежит классу, а не объекту. Когда использовать статические свойства?Хранить общее состояние. Пример: счётчик созданных объектов.Статическое свойство для конфигурации или глобальных параметров. Статическое свойство для кэша или пула ресурсов.  Например пул соединений не создает новый а переиспользует созданный. 1.Нарушение инкапсуляции. 2. Глобальное состояние - сложно тестировать. 3. Наследование может запутать
	19. Вызовы this self static parent -  this - ссылка на текущий экземпляр (объект), self - Используется для обращения к статическим членам. static -  динамическое связывание, учитывает иерархию классов (позднее связывание).`parent` — это ссылка на родительский класс.	
	20. Магические методы. destruct - вызывается один раз за жизнь объекта, в момент его удаления из памяти. Когда срабатывает явно уничтожается unset завершаеться скрипт и php очищает память. не используется для бизнес логики. get -  магический объект обращении к недоступному (приватному, защищённому или несуществующему) свойству объекта. ипользыется там где нужен гибкий доступ к даннымм. трудно отлаживать. использование магии влияет на производительность. set это магический метод который перехватывать присвоение к несуществующим или приватным свойствам. Частый сценарии применения. Часто используеться в паре с магическим свойстом get. Динамическое хранение атрибутов. Валидация и фильтрация данных. Ленивое создание или проксирование. isset это магический метод он служит для контроля проверки наличия значени в свойствах, когда  прямой доступ невозможен например приватные свойства. unset - это магический метод который использует метод unset() для приватный или несущесвующих свойст объекта. call - это магический метод PHP, который автоматически вызывается при попытке вызвать недоступный или несуществующий метод объекта. Он позволяет перехватывать вызовы методов и реализовывать динамическое поведение объектов. Частое применения. Динамическое создание методов - например гет или сет. Обработка неявных или универсальных вызовов.  метод call перехватывает вызовы и решает, как их обработать. Это удобно в случаях, когда набор методов не фиксирован. Плюсы калл гибкость и динамичность. сокращение дублирования кода. реализация паттернов проективания. Отладка и логирование. Минусы калл. потеря явности кода. сложность отладки. потенциальные ошибки во время выполнения. накладный расходы на производительность. ухудшает архитектуру. callStatic - работает как call, вызываетяс статический метод, который не объявлен в классе или не досупен в классе. toString - спеуиальный нестатический метод, который автоматически вызывается когда объект требуется представить в строковом конетксте метод должен строго вернуть стринг.Преимущество удобочитаемость, улучшения отладки и логирование, чистые шаблоны, объект самсебя представляет  SRP И DDD. invoke - магический метод который позволяет объект вести себя как функццию. т.е. быть вызываемым через скобки, как если бы это был замыкание или обычная функция. сценарии использования. Замена анонимной функции. объект создаёт и возвращет экземпляр при вызове. Подваодный камни инвоке не должен содержать бизнес-логику, которую сложно протестировать. избыточное использование усложняет читаемость кода, в больших проектах предпочтительнее явные методы, особенно если у объекта есть несколько целей. Когда объект должен выполнять одну чёткую функцию. когда его удобно передавать как callable(например в array_map) Когда требуется функциональный стиль кода (особенно в трансформациях, фильтрациях, стратегиях). Это мощный инструмент, который стоит применять, когда он делает архитектуру чище и выразительнее, но не стоит использовать его повсеместно вместо обычных методов.  Магический метод clone это способ создать копию объекта, при этом управляя глубиной копирования наличие вложенных объектов. Применения. при наличии вложенных объектов. Очистка или обнуление данных. Генерация нового состояния т.е при клонирование может сразу поминять состояния атрбиуто. Безопасное клонирование чтобы избежать расшаренных ссылок между объектами. sleep современный анналог сериализе - магический метод для используется при сериализации объекта. Он должен вернуть массив имён свойств которые должны быть сериализованы. Подготовить объект к сериализации. сохранить состояние очистить временные поля. освободить ресурсы. вернуть только те свойства, которые дествительно нужны.Что нельзя делать в sleep нельзя.Нельзя сериализовать ресурсы (например, PDO, curl, file handle). Не стоит сериализовать внутреннее состояние фреймворков, сессий. wakeup и unserialize - гебкий и безопасный контроль восстановления состояния объекта. когда использовать wakeup восстановить соединения, переподключить ресурсы, заново инициальзировать кэш, di, зависимости, проверить целостность и безопасность.Недостаки. Не даёт доступа к входным данным напрямую. Может вести себя нестабильно, если объект повреждён. Может быть уязвим для атаки через подмену сериализованных данных. Магические методы. Сериализация. Дезериализации (sleep,wakeup,serialize,unserialize). Доступ к несуществующим свойствам(get, set, isset, unset). Вызов несуществующих методов(call, callstatick). Поведение как строка, функция и массив(toString, invoke, debugInfo). клонирование объектов(clone)
	21. Композер это менеджер пакетов и зависимостей. Что обеспечивает композер. Управление зависимостями(Версии)(^ caret -  разрешить все несовершеннолетние обновления, но не переходить на следующий MAJOR, потому что это может сломать совместимость, ~ tilde  Когда вы хотите безопасно обновлять патчи и незначительные изменения, но не переходить на следующий MAJOR, * звёздочка - подразумевает любая доступная версия, piple - или выбрать между версиями). Автозагрузка - Composer автоматически генерирует файл автозагрузки, который подключает классы при обращении к ним, по соглашению PSR-4. Упрощает архитектуру: не нужно явно require каждый класс. Изоляция проектов Composer по умолчанию устанавливает библиотеки локально в папку vendor/ текущего проекта, а не глобально в систему.Интеграция в CI/CD (повторяемость сборок).Самые частые проблемы при работе с composer. Конфликт зависимостей. Композер слишком долго работает или зависает решение обновить композер. Изменения не применяються после обновления пакета. удалить кеш автолода. Автозагрузка не работает(классы не находятся). Composer audit нашёл уязвимости.
	22. readonly — это модификатор свойства, который указывает, что значение этого свойства можно установить только один раз, при создании объекта в конструкто или прямой инициализации при объявлении. Когда использовать readonly. В избежении случайной перезаписи.Повышает предсказуемость и устойчивость. Безопасность и контроль изменений. Что запрещено с readonly. Изменение после установки. Использование сетеров.Особенность редонли не защищает от изменения внутри объекта или массива получаеться редонли запрещает менять саму ссылку, но не объект по ссылке.
-  Архитектура, паттерны, особенности ООП
	1. SOLID - S(Single Responsibility Principle)Принцип единственной ответтственности.Класс должен выполнять только одну чётко определённую задачу или отвечать за один аспект поведения. Практическое применение. Класс делает слишком много. Вы не можете точно сформилировать, за что он отвечает. Если у него слишком много зависимостей и побочных эффектов. Почему это важно. Упрощает сопровождение - изменение одной части не ломает другую. Повышает переиспользование. Маленькие классы легче комбинировать. Облегчает тестирование меньше зависиммостей -проще моки. Повышает читаемость - код лучше отражает бизнес-логику. O(Open/Closed Principle) - этот принцип ознчает открыт для расширение, можно добавить новое поведение, закрыт для изминения - не нужно изменять существующиц код, что бы внедрить новое поведение. Суть еще раз не изменять проверенный и протестированный код а добавлять новое поведение через расширение(наследование,реализацию интерфейсов,делегирование). Почему это важно. Стабильность провереный код не трогать - меньше багов.Расширяемость Новое поведение через новые классы.L (Liskov Substitution Principle, LSP) - Поведение подкласса должно полностью удовлетворять контракту базового класса (интерфейса); клиентский код не должен замечать подмены. Классические нарушения. Ужесточение предусловий, подкласс делает более строгие правила.Ослабление постусловий, подкласс делает более мягкий правила. Новое исключение, добавлено новое исключение в подклассе. Практические приёмы соблюдения lsp. Отделяйте интерфейсы, Делайте контракты минимальными; расширяйте поведение через композицию. Не наследуйте ради удобства. Наследование – для is‑a, а не просто «чтобы не дублировать код». Проверяйте предусловия/постусловия (assert/throw)  Подтип не должен требовать больше и гарантировать меньше. Избегайте.override state‑mutating методов, если у подтипа иные инварианты.  Либо перенесите различие во внутреннюю реализацию (шаблон _Strategy_). Один из способ решений сделать более честную архитектуру. Шпаргалки задать такие вопросы.  Могу ли я передать подтип в существующую функцию без правки кода? Будет ли соблюдён контракт методов (исключения, инварианты)Не произойдёт ли усиления предусловий или ослабления постусловий?Соответствуют ли новые значения тем же ограничениям?I Interface Segregation Principle (ISP) - Лучще несколько маленьких интерфесов, чем один большой униварсальный. Суть. Представьте, что вы обязали класс реализовать интерфейс с 10 методами, но ему реально нужны только 2 из них. Остальные — ненужная нагрузка, а часто — даже противоречивые обязанности. Почему ISP важен. Повышает читаемость. Упрощает тестирование. Облегчает расширение. Снижает связность. D Dependency Inversion Principle (DIP) -  Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций. Простыми словами код должен зависеть от интерфейсов, а не от конкретной реализаций.Зависимости должны идти от абстракций, а не от деталей.
	2. Порождающие паттерны - упростить создание объектов и разделить логику создания объекта от его использования тоесть инкапсуляция процесса. Их идея скрыть детали создания объекта, особенно когда процесс солжный зависит от условий, или может меняться со временем. Классические порождающие паттерны (по GoF)- Singleton (Одиночка).Factory Method (Фабричный метод).Abstract Factory (Абстрактная фабрика).Builder (Строитель). Prototype (Прототип). В не Gof.Static Factory (Статическая фабрика)Object Pool (Объектный пул).Multiton (Мультитон).Lazy Initialization (Ленивая инициализация).Dependency Injection (Внедрение зависимостей). Service Locator (Локатор сервисов). Почеме это важно. Позволяют легко менять способ создания объектов. Снижают связанность между компнентами. Поддерживают принцип создание и использование должны быть раделены.
	3. Структурные паттерны определяют способы построения отношений между объектами и классами для формирования более гибких и масштабируемых архитектур.Они помогают правильно организовать взаимодействие между частями системы, обеспечивая повторное использование кода, расширяемость и читаемость. Основная цель. Объединить классы и объекты в структуры, которые удобно масштабировать и сопровождать, не нарушая принципы инкапсуляцию и слабой связанности. Организация и упрощение связей между объектами и классами, чтобы система была гибкой, расширяемой и понятной.Структурные паттерны по Gof - Adapter (Адаптер) Bridge (Мост) Composite (Компоновщик) Decorator (Декоратор) Facade (Фасад) Flyweight (Приспособленец) Proxy (Заместитель). Структурные паттерны не по Gof DTO (Data Transfer Object). Value Object. Entity. Repository. Service Layer (Сервисный слой). Anti-Corruption Layer (ACL). Normalizer / Mapper / Transformer.  Service Locator.Layered Architecture. Gateway. Bounded Context Interface. Почеме это важно.  Обеспечивают правильную архитектуру компонентов. Позволяют легко заменять, расширять или адаптировать части системы. Поддерживают принцип слабой связанности.
	4. Поведенческие паттерны описывают способы взаимодействия объектов между собой$payFactory,  а также ответственность и алгоритмы, которые они реализуют. Они помогают организовать обмен сообщениями между объектами, чтобы система оставалась гибкой и масштабируемой. Обеспечить гибкое взаимодействие объектов, разделение обязанностей и расширяемость поведения без изменения существующего кода. Изолируют алгоритмы и сценарии поведения, снижают связанность между классами, упрощают добавление нового поведения. Почему это важно Упрощают добавление нового поведения без изменения существующего кода Позволяют гибко управлять алгоритмами, событиями, состояниями Поддерживают принципы открытости к расширению и замкнутости к модификации (OCP).
	5. https://www.notion.so/PHP-e5e83ab9142d493d956b05d4212de766
	6. Нейминг - Имена должны быть осмысленными и точными. Избегайте аббревиатур и сокращений. Имя должно отвечать на вопрос: "Что это?" или "Что делает?". Нейминг классов. Имя - существительное, отражающее суть класса. Имя класса вопрос к чату.
	   Напиши несколько подходящих названий классов. Название класса должно быть. Имя существительное, отражающее суть класса, должны быть осмысленными и точными. Название класса не должно быть. Избыточным, слишком Абстракным. Нейминг Метода глагол или глагольная фраза, должно точно описывать поведение. Имя метода вопрос к чату. Напиши несколько подходящих названий классов. Название метода должно быть. Имя — глагол или глагольная фраза, должно точно описывать поведение, должны быть осмысленными и точными. Название метода не должно быть. Избыточным, слишком Абстракным. Нейминг переменных. Должны отражать тип и назначение. не должны быть бесполезные обобщения. Имя метода вопрос к чату. Напиши несколько подходящих названий классов. Название переменных должно быть. Должны отражать тип и назначение, должно точно описывать поведение, должны быть осмысленными и точными. Название переменной не должно быть. Избыточным, слишком Абстракным.
	7. Бизнес-логика (или доменная логика) — это набор правил, ограничений и сценариев, определяющих, как работает предметная область внутри приложения. моделировать реальное поведение и процессы в рамках предметоной области. принимать решения, основанные на бизнес-правилах. Зачем важно отделять бизнес-логику. Поддерживаемость. Изменения в бизнесе не должно затрагивать инфраструктору. Тестируемость. Можно писать юнит-тесты без моков фреймворка. можно преиспользовать логику через разные интерфейсы. Признаки бизнес-логики. - изменяет состояние сущности по правилам Архитектурные паттерныпредметной области. проверяет или применяет бизнес-ограничения. реализует прикладной сценарий (например, оформление заказа, списание баланса. может быть описан бизнес-аналитиком или предметным экспертом. не зависит от фреймворков и технологий (в идеале).нуждается в тестировании через юнит-тесты.
	8. Архитектурные паттерны — это высокоуровневые шаблоны проектирования, которые определяют общую структуру и организацию системы.
	9. MVC (Model–View–Controller) — это один из самых распространённых архитектурных шаблонов проектирования, особенно в веб-разработке. Он используется для разделения логики приложения на три независимых компонента: Model, View, Controller. Model - отвечает за. бизнес-логику, работу с базой данных, правила валидации, доступ к данным. View(Представление) - html - шаблоны. Controller - обработка http запросов управление взаимодействием между view и model. Что делает. получает данные из запроса, вызывает нужные можель возвращает шаблон и данные
	10. DDD - это подход к разработке программного обеспечения, который фокусируется на моделировании сложной бизнес-логики (домена) и её глубоком понимании. Цель DDD создать архитектуру и код, который отражают суть бизнеса, а не просто технические детали. DDD направлен не то, чтобы разработчики и эксперты домена говорили на одном языке и вместе создавали модель. Основные принципы DDD. Фокус на домене. основное внимание - на бизнес-правилах и процессах. Ubiquitous Language единый язык между командой и бизнесом. Разделение модели и инфраструктуры: бизнес-логика — отдельно, детали реализации — отдельно.Изоляция доменных областей: каждая область проектируется как автономный модуль. Основные строительные блоки DDD. Entity(Сущность) это объект, у которого есть устойчивый идентификатор и жизненный цикл. Её состояние может меняться, но она остаётся той же сущностью. Value Object — это объект, который определяется только набором значений, и не имеет идентичности. Repository — это паттерн доступа к данным агрегата, скрывающий детали хранения. Он предоставляет коллекцию объектов в памяти, хотя может обращаться к БД, API и т.д. Domain Service Когда операция не относится напрямую к одной сущности, её можно реализовать как доменный сервис. Он содержит чистую бизнес-логику, не зависящую от инфраструктуры. Application Service (Сервис приложения).Это слой, который управляет координацией бизнес-операций, используя доменные сущности и сервисы.  Domain Event (Событие домена)Событие домена — это факт, который произошёл в системе и важен для бизнес-логики.  Используются для реакции на изменения, слабой связанности, интеграции между модулями.
	11. TDD (Test-Driven Development) — это подход к разработке программного обеспечения, в котором тесты пишутся до реализации функциональности. Этот подход меняет традиционный порядок действий и даёт разработчику целый ряд преимуществ в плане надёжности, поддерживаемости и качества кода. Или когда нам будет сложно про тестировать существующий код.
	12. Вертикальное и горизонтальное масштабирование - вертикальное это когда мы увеличимаем мощность одного сервера, а горизонтальное - добавление несколько серверов в систему, которые работают параллельно и распределяют нагрузку.
-  Основы тестирование
    1. Верификация - процесс оценки конечного продукта, чтобы проверить, соответствует ли он требованиям.
    2. Валидация - процесс оценки конечного продукта, чтобы проверить, соответствует ли он потребностям бизнеса и ожиданиям клиентов.
    3. [Виды тестирование](https://www.notion.so/737708a13eb045ceb1b3d4492a19c162?pvs=21) (какие есть)
    4. Пирамида тестирование(Модельное тестирование, интеграционное тестирование, системное тестирование, приемочное тестирование E2E)
    5. Жизненный цикл разработки(Сбор и анализ требований, Дизайн, Разработка, Тестирование, Развертывание, Поддержка)
    6. Жизненный цикл тестирования(Анализ требований, планирование тестирование, проектирование тестов, выполнение тестов, оценка тестов, отчет тестирование).
    7. Жизненный цикл бага(Новый баг, Назначен, Устранен, Проверен, Закрыт, Повторно открыт)
    8. Принципы тестирования(Тестирование демонстрирует наличие дефектов, Исчерпывающее тестирование недостижимо (невозможно), Раннее тестирование, Скопление/кластеризация дефектов, Парадокс (эффект) пестицида, Тестирование зависит от контекста, Заблуждение об отсутствии ошибок)
    9. Техники тест дизайна(Классы эквивалентности, Граничные значения, Попарного значения, Диаграмма состояний, Таблица принятия решений)
    10. Мобильное тестирование(Нативное приложения, веб-приложения, гибридное приложения) Требование**:**
    11. Виды требование(Функциональные требования, Нефункциональные требования, Бизнес-требования, Системные требования, Пользовательские требования).
    12. Основные проблемы, связанные с требованиями?(Неясные или неполные требования, Частые изменения требований, Невозможность реализации требований, Игнорирование нефункциональных требований)
    13. Практики управления требованиями! Какие есть?(Валидация требований, Приоритизация, Использование методологий Agile и DevOps, Прототипирование и демонстрации)
    14. Свойства качественных требований(Полнота, Однозначность, Трассируемость, Проверяемость, Необходимость, Последовательность, Реализуемость)
-  ООП java
    
    1. ооп - это парадигма программирования, основанная на концепции "объектов", которые содержат как данные, так и методы для их обработки.
        
    2. Инкапсуляция - позволяет скрывать внутренние детали реализации объектов и открыв только то, что необходимо при последующем использовании.(_Пример:_ Гетеры и сетеры)
        
    3. Наследование - позволяет описать новый класс на основе уже существующего
        
    4. Полиморфизм - можно использовать методы одного интерфейса с различными объектами, что упрощает расширение функциональности.
        
    5. Aбстракция - это способ выделить набор всех общих характеристик объекта
        
    6. JVM(Java Virtual Machine) - Загрузка, проверка и исполнение байт кода
        
    7. JRE(Java Runtime Environment) - Загрузка классов.
        
    8. JIT(Java Development Kit) - компилятор устраняет недостатки интерпретатора.
        
    9. Ключевое слово final(константа) - (Класс не может иметь наследников, Метод не может быть переопределен в классах наследниках, Поле не может изменить свое значение после инициализации, Параметры методов не могут изменять своё значение внутри метода, Локальные переменные не могут быть изменены после присвоения им значения).
        
    10. Метод `main()` — точка входа в программу.
        
    11. Абстрактные классы содержат частичную реализацию, которая дополняется или расширяется в подклассах - .«is a» (является)
        
    12. Класс — это шаблон или чертеж, который определяет свойства (переменные) и поведение (методы) для объектов. Класс описывает общие характеристики и действия, которые могут быть присущи объектам данного типа.
        
    13. Объект — это экземпляр класса, созданный на его основе. Он представляет собой конкретную реализацию класса, в которой переменные имеют свои значения, а методы могут быть вызваны для выполнения действий.
        
    14. Конструктор — это специальный метод класса, который автоматически вызывается при создании объекта и используется для его инициализации.
        
    15. Переопределение метода - метод родительского класса и создать специфическую реализацию в классе-наследнике.
        
    16. Перегружен - имеет одинаковое название, но может отличаться параметрами.
        
    17. _Enum_ (Перечисление) - это тип, который представляет набор заранее определенных констант. Он используется для того, чтобы перечислить возможные значения переменной.(Можно использовать методы, конструктуры)
        
    18. Статический класс — это класс, который может быть объявлен внутри другого класса (вложенный класс) Вложенные классы - нужен для ****инкапсуляция. Нужно задать вопрос может ли вложенный класс сущестовать отдельно от супер класса. Если да то вложенный класс скорей всего не пойдет
        
    19. Nested Inner classes (вложенные внутренние классы) - ****_Он может получить доступ к любому приватному полю или методу экземпляра внешнего класса._
        
    20. Static Nested classes (статические вложенные классы) - _Статические вложенные классы имеют доступ к статическим полям внешнего класса (в том числе приватным). Но не имеют доступа к полям экземпляра._
        
    21. Method Local Inner classes - _могут обращаться к переменным метода (если они являются final или effectively final)._
        
    22. Анонимные классы (Anonymous Classes) - внутренние классы объявляются без указания имени класса. Они могут быть созданы двумя путями:
        
    23. Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части приложения.
        
    24. Stack (стек) - для простых переменных
        
    25. Сборщик мусора - находит мусор, находит те объекты на котором перед выполнение тестов нет ссылок
        
    26. Коротко разница Интерфейсом и Aбстракции - абстракция используется когда есть общая логика а интерфейс когда просто задать общие требования к набору методов для разных классов.
        
    27. Композиция: Это сильное отношение "целого и частей", когда объект состоит из других объектов, и эти объекты не могут существовать отдельно от "целого".
        
    28. Агрегация: Это слабое отношение "целого и частей", при котором объекты могут существовать независимо друг от друга.
        
    29. Generics - это механизм, который позволяет указать чёткую типизацию для компилятора
        
    30. _«Коллекция»_ - это структура данных, набор каких-либо объектов.
        
    31. Сериализация -это когда мы меняем один формат на другой Колекции List (список) представляет собой коллекцию, в которой допустимы дублирующие значения
        
    32. ArrayList - позволяет хранить элементы в виде динамического массива.
        
    33. LinkedList - которая представляет собой связный список. Каждый элемент списка хранит ссылку на следующий и предыдущий элементы, что позволяет эффективно добавлять и удалять элементы с начала и конца списка.
        
    34. Vector - синхронизирован, что делает его потокобезопасным.
        
    35. Stack - последний добавленный элемент будет первым, который будет извлечён set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.
        
    36. HashSet в Java — это реализация интерфейса Set, которая используется для хранения уникальных элементов, то есть элементы не могут дублироваться.
        
        1. LinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов. Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out): MAP **-** Каждый ключ уникален и ассоциирован с определенным значением.
            
        2. HashMap:
            
            - Основана на хеш-таблице.
            - Быстрый доступ к элементам благодаря использованию хеширования.
            - Неупорядоченная структура — элементы не гарантированно будут храниться в порядке их добавления.
            - Допускает null как для ключей, так и для значений.
        3. LinkedHashMap:
            
            - Наследует от HashMap, но поддерживает порядок вставки элементов.
            - Чуть медленнее, чем HashMap, из-за поддержания порядка.
        4. TreeMap:
            
            - Основана на красно-чёрном дереве.
            - Хранит элементы в отсортированном порядке по ключам (натуральный порядок или компаратор).
            - Медленнее по сравнению с HashMap.
        5. Hashtable:
            
            - Старый класс, похожий на HashMap, но синхронизированный (потокобезопасный).
            - Не допускает null в качестве ключа или значения. Паттерны
            
            Многопоточность
            
    37. Многопоточность в Java — это механизм, позволяющий программе выполнять несколько потоков (threads) одновременно. Каждый поток представляет собой отдельную нить выполнения внутри процесса. Это полезно для повышения производительности и эффективного использования ресурсов. Вы можете создать новый поток, наследуя класс Thread и переопределив метод run(). Дженерик
        
    38. Maven — это инструмент для автоматизации сборки проектов, который используется в основном
        
    39. api ****- позволяет разным программам или системам взаимодействовать друг с другом.
        
    40. SOLID-принципы — это набор из пяти основных принципов объектно-ориентированного программирования (ООП).
        
    41. SOLID(S) - Single Responsibility Principle (Принцип единственной ответственности)
        
    42. SOLID(O) - Open/Closed Principle (Принцип открытости/закрытости)
        
    43. SOLID(L) - Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
        
    44. SOLID(I) - Interface Segregation Principle (Принцип разделения интерфейса)
        
    45. SOLID(D) - Dependency Inversion Principle (Принцип инверсии зависимостей)
        
    46. Паттерны авто тестирование (Одиночка)(SingleTon) - используется в основном конфигурации
        
    47. Паттерны авто тетсирование(Строитель)(Builder) - используиться для добавления каких либо параметров
        
    48. Паттерн авто тестирование(Декоратор) -
        
    49. Паттерн авто тестирование(Фасад) - это когда у нас закрыт доступ ко всем функциональнастям а есть только библиотека в которой мы можем вызвать все методы
        
    50. Паттерн авто тестирование(Наблюдатель) - конфигурация за слишком статуса прохождения тестирование allure(библиотека)
        
    51. Классы обёртки - нужны для вычислений
        
    52. Автоматическая упаковка (autoboxing)  - это механизм неявного создания (без использования оператора new) объекта класса-обертки.
        
    53. Автоматическая распаковка (unboxing) - это механизм неявного преобразования объекта типа-обертки в примитивный тип
-  Программы для автотестирование java
    
    Автотестирование на Java — это важная часть процесса разработки, и существует множество инструментов, которые помогают автоматизировать тестирование кода. Вот несколько популярных инструментов, используемых для различных видов автотестирования на Java:
    
    ### 1. **JUnit**
    
    - **Описание**: JUnit — это один из самых популярных фреймворков для модульного тестирования в Java. Он позволяет создавать и выполнять тесты для отдельных классов и методов.
        
    - **Особенности**: Простота в использовании, поддержка аннотаций для управления тестами (`@Test`, `@Before`, `@After` и т.д.), возможность интеграции с инструментами сборки.
        
    - **Пример**:
        
        ```java
        java
        Копировать код
        import org.junit.jupiter.api.Test;
        import static org.junit.jupiter.api.Assertions.assertEquals;
        
        public class CalculatorTest {
            @Test
            public void testAdd() {
                Calculator calculator = new Calculator();
                assertEquals(5, calculator.add(2, 3));
            }
        }
        
        ```
        
    
    ### 2. **TestNG**
    
    - **Описание**: TestNG — это еще один фреймворк для модульного тестирования, похожий на JUnit, но с расширенными возможностями, такими как параллельное выполнение тестов, гибкая конфигурация и поддержка зависимостей между тестами.
        
    - **Особенности**: Параллельное тестирование, параметризация тестов, удобная интеграция с CI/CD.
        
    - **Пример**:
        
        ```java
        java
        Копировать код
        import org.testng.annotations.Test;
        import static org.testng.Assert.assertEquals;
        
        public class CalculatorTest {
            @Test
            public void testAdd() {
                Calculator calculator = new Calculator();
                assertEquals(5, calculator.add(2, 3));
            }
        }
        
        ```
        
    
    ### 3. **Selenium**
    
    - **Описание**: Selenium — это инструмент для автоматизации браузеров, используемый для написания функциональных и интеграционных тестов веб-приложений.
        
    - **Особенности**: Поддержка различных браузеров, языков программирования (в том числе Java), и интеграция с различными фреймворками и CI/CD инструментами.
        
    - **Пример**:
        
        ```java
        java
        Копировать код
        import org.openqa.selenium.WebDriver;
        import org.openqa.selenium.chrome.ChromeDriver;
        
        public class SeleniumTest {
            public static void main(String[] args) {
                WebDriver driver = new ChromeDriver();
                driver.get("<https://www.example.com>");
                System.out.println(driver.getTitle());
                driver.quit();
            }
        }
        
        ```
        
    
    ### 4. **Mockito**
    
    - **Описание**: Mockito — это библиотека для создания mock-объектов в тестах, которые позволяют изолировать тестируемые компоненты и имитировать их взаимодействие с внешними зависимостями.
        
    - **Особенности**: Простота создания заглушек и шпионов, гибкость в настройке поведения mock-объектов.
        
    - **Пример**:
        
        ```java
        java
        Копировать код
        import static org.mockito.Mockito.*;
        import org.junit.jupiter.api.Test;
        
        public class ServiceTest {
            @Test
            public void testService() {
                Dependency dependency = mock(Dependency.class);
                when(dependency.getData()).thenReturn("Mocked data");
        
                Service service = new Service(dependency);
                assertEquals("Mocked data", service.getData());
            }
        }
        
        ```
        
    
    ### 5. **Cucumber**
    
    - **Описание**: Cucumber — Он позволяет писать тесты в формате, который понятен как разработчикам, так и бизнес-пользователям.
        
    - **Особенности**: Сценарии тестирования на основе примеров, интеграция с JUnit и TestNG.
        
    - **Пример** (Gherkin):
        
        ```gherkin
        gherkin
        Копировать код
        Feature: Calculator
          Scenario: Addition
            Given the calculator is open
            When I add 2 and 3
            Then the result should be 5
        
        ```
        
    
    ### 6. **AssertJ**
    
    - **Описание**: AssertJ — это библиотека, расширяющая возможности стандартных assertion в JUnit/TestNG. Она предоставляет более читаемые и мощные утверждения.
        
    - **Особенности**: Fluent API для утверждений, поддержка более сложных операций с коллекциями и объектами.
        
    - **Пример**:
        
        ```java
        java
        Копировать код
        import static org.assertj.core.api.Assertions.assertThat;
        
        @Test
        public void testList() {
            List<String> list = Arrays.asList("apple", "banana", "orange");
            assertThat(list).hasSize(3).contains("apple", "orange");
        }
        
        ```
        
    
    ### 2. **Rest Assured**
    
    - **Описание**: Java-библиотека для тестирования REST API. Rest Assured упрощает процесс отправки HTTP-запросов и проверки ответов в тестах на Java.
        
    - **Особенности**: Легкая интеграция с JUnit/TestNG, поддержка различных методов HTTP, JSON и XML формат данных.
        
    - **Пример использования**:
        
        ```java
        java
        Копировать код
        import io.restassured.RestAssured;
        import static io.restassured.RestAssured.*;
        import static org.hamcrest.Matchers.*;
        
        @Test
        public void testApi() {
            RestAssured.baseURI = "<https://api.example.com>";
            given().
                param("key", "value").
            when().
                get("/endpoint").
            then().
                statusCode(200).
                body("data.id", equalTo(1));
        }
        
        ```
        
    
    ### 3. **SoapUI**
    
    - **Описание**: Инструмент для тестирования SOAP и REST API. SoapUI поддерживает как функциональное, так и нагрузочное тестирование.
    - **Особенности**: Поддержка сложных сценариев тестирования с передачей данных между запросами, встроенные средства для тестирования безопасности API.
    - **Пример использования**: Тестирование SOAP-веб-сервисов, создание сценариев для REST API, проведение нагрузочного тестировани