- Перфоманс
    
    > Я занимался авто тестированием в течение полтора года.В основном тестировал бэк. Работал в компании OPTIMAX. Автотесты писал на codeception и так же делал ручные задачи.По автотестам делал (клиенты, энтити, контракты, хелперы, ). Моя домена зона была главная страница сайта(elasticsearch), и админка(Magento).Работал c sql, kafka, postman, allure, docker, ci/cd.
    
    > по sql - делал запросы используя(джоины, подзапросы)
    
    > kafka - в основном смотрел какие сообщения приходят
    
    > postman - делал большие коллекции использовал(скрипты, переменные, тесты)
    
    > allure - писал подробный отчет автотестов. Можно сказать allure из автотеста делал тест-кейсы docker - нужен был только для развертывания проекта. ci/cd - опыта настройки нет тестовая документация в зефире щас переходят на xray
    
- Сравнение XML и JSON
    
    - Правила и ошибки JSON [JSON](https://ru.wikipedia.org/wiki/JSON) (JavaScript Object Notation) - простой формат обмена данными
        
        ### **Основные типы, которые могут быть представлены в JSON:**
        
        1. **Объект (словарь, ассоциативный массив)**:
            - Пример: `{"name": "John", "age": 30}`
        2. **Массив**:
            - Пример: `[1, 2, 3, 4]`
        3. **Строка**:
            - Пример: `"Hello, World!"`
        4. **Число**:
            - Пример: `42`, `3.14`
        5. **Логическое значение**:
            - Пример: `true`, `false`
        6. **`null`**:
            - Пример: `null`
        
        ### **Преимущества JSON:**
        
        7. **Меньше объём и компактность по сравнение с XML - так как в xml слишком много тегов**
        8. **Легкость в использовании. Для обработки программно — большинство языков программирования**
        9. **Парсинг обычно быстрый чем** **XML - так же иза обработки тегов**
        10. **Широкая поддержка в веб-разработке**
        
        ### Недостатки JSON:
        
        11. **Отсутствие поддержки схем - это означает нужно полагаться на дополнительнные инструменты JSON Schema**
        12. **Ограничность метаданных - это то что в XML можно указать атрибуты в json нельзя.**
        13. **Меньше гибкости для сложных документов.Причины: 1)Отсутсвие атрибутов 2)Сложные иерархии - XML лучше подходит для представление сложных иерархий данных 3)Нет явной структуры для документов с разными типами данных**
        
        - { "message": "Hello "world"" } **ЭКРАНИРОВАТЬ** json что нужно знать
            
            **1)Кавычки “ нужно экранировать обязательно**
            
            ### **2)Экранирование обратных слэшей**
            
            Если ты хочешь использовать сам обратный слэш (`\\`), его нужно экранировать. Например:
            
            Пример:
            
            ```json
            
            { "path": "C:\\\\Users\\\\User\\\\Documents" }
            { "quote": "He said: \\"Hello!\\"" }
            
            ```
            
            - **Новая строка**: `\\n`
            - **Табуляция**: `\\t`
            - **Обратный слэш**: `\\\\`
            - **Кавычки (внутри строки)**: `\\"`
            - **Возврат каретки**: `\\r`
            - **Пространство (непечатаемый символ)**: `\\b`
            - **Форматируемая строка (для строк в Unicode)**: `\\uXXXX` (где `XXXX` — это 4 цифры в шестнадцатеричной системе)
        
        ### 1. **Неправильное использование кавычек**
        
        - **Ошибка**: Использование одинарных кавычек вместо двойных.
            
            - **Неправильно**:
                
                ```json
                { 'name': 'John' }
                
                ```
                
            - **Правильно**:
                
                ```json
                { "name": "John" }
                
                ```
                
        - В JSON только строки заключаются в **двойные кавычки**, а не одинарные.
            
        
        ### 2. **Отсутствие кавычек вокруг строк**
        
        - **Ошибка**: Не заключение строк в кавычки.
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                { name: "John" }
                
                ```
                
            - **Правильно**:
                
                ```json
                jsonКопировать код
                { "name": "John" }
                
                ```
                
        
        ### 3. **Использование висячей запятой**
        
        - **Ошибка**: Лишняя запятая в конце последнего элемента.
            
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                {
                  "name": "John",
                  "age": 30,
                }
                
                ```
                
            - **Правильно**:
                
                ```json
                jsonКопировать код
                {
                  "name": "John",
                  "age": 30
                }
                
                ```
                
        - Запятая ставится только между элементами, а не после последнего.
            
        
        ### 4. **Неправильный тип данных**
        
        - **Ошибка**: Значения не соответствуют типу данных JSON.
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                { "age": "30" }
                
                ```
                
            - **Правильно** (если это число):
                
                ```json
                jsonКопировать код
                { "age": 30 }
                
                ```
                
        
        ### 5. **Использование комментариев**
        
        - **Ошибка**: В JSON **нельзя** использовать комментарии.
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                {
                  "name": "John", // комментарий
                  "age": 30
                }
                
                ```
                
            - **Правильно**: Уберите комментарии:
                
                ```json
                jsonКопировать код
                {
                  "name": "John",
                  "age": 30
                }
                
                ```
                
        
        ### 6. **Пропуск скобок**
        
        - **Ошибка**: Пропущены фигурные скобки для объектов или квадратные скобки для массивов.
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                "name": "John", "age": 30
                
                ```
                
            - **Правильно**:
                
                ```json
                jsonКопировать код
                {
                  "name": "John",
                  "age": 30
                }
                
                ```
                
        
        ### 7. **Неэкранированные символы**
        
        - **Ошибка**: Использование символов, которые нужно экранировать.
            - **Неправильно**:
                
                ```json
                jsonКопировать код
                { "message": "Hello "world"" }
                
                ```
                
            - **Правильно** (экранирование символов с помощью обратной косой черты):
                
                ```json
                jsonКопировать код
                { "message": "Hello \\"world\\"" }
                
                ```
                
        
        ### 8. **Проблемы с кодировкой**
        
        - **Ошибка**: Использование некорректных символов UTF-8, которые могут не поддерживаться в JSON.
            - Всегда проверяйте, что строка JSON имеет корректную кодировку (UTF-8).
        
        ### Основные правила формирования JSON:
        
        1. **Корневой элемент** — должен быть либо объектом `{}`, либо массивом `[]`.
        2. **Ключи** — строки в двойных кавычках.
        3. **Значения** — могут быть строками, числами, объектами, массивами, булевыми значениями или `null`.
        4. **Отсутствие комментариев** — комментарии в JSON не допускаются.
        5. **Без лишних запятых** — после последнего элемента не должно быть запятых.
    - Правила и ошибки XML
        
        **xml** - расширяемый язык разметки. Используется для хранения и передачи данных. **<?xml version="1.0" encoding="UTF-8"?> -можно указать версию и кодировку в начале.**Атрибуты могут быть добавлены к тегам. Атрибуты определяются внутри начального тега и указываются как пары `ключ="значение"`.
        
        ### Приемущества XML
        
        1. **Читаемость человеком и машиной. Имеет чёткую структуру с открывающимми и закрвающими тэгамии**
        2. **Гибкость и расширяемость**
        3. **Поддержка схем и валидации (XSD) - можно легко провалидировать данные указать тип размер длину и т.д**
        4. **Поддержка метаданных**
        
        ### Недостатки XML
        
        5. **Требует больше пространства**
        6. **Меньше производительность**
        7. **Сложность**
        8. **Избыточность**
        9. **Трудность в чтении и написании**
        
        ### 1. **Отсутствие или неправильное использование корневого элемента**
        
        - **Ошибка**: В XML должен быть только **один корневой элемент**.
            
            - **Неправильно**:
                
                ```xml
                <book>
                  <title>XML Guide</title>
                </book>
                <author>John</author
                ```
                
            - **Правильно**:
                
                ```xml
                <document>
                  <book>
                    <title>XML Guide</title>
                  </book>
                  <author>John</author>
                </document>
                ```
                
        - В XML должен быть только один элемент верхнего уровня, называемый корневым.
            
        
        ### 2. **Неправильное закрытие тегов**
        
        - **Ошибка**: Открытые теги **должны быть закрыты**.
            - **Неправильно**:
                
                ```xml
                <book>
                  <title>XML Guide
                </book>
                
                ```
                
            - **Правильно**:
                
                ```xml
                <book>
                  <title>XML Guide</title>
                </book>
                ```
                
        
        ### 3. **Пробелы и символы в именах тегов**
        
        - **Ошибка**: В именах тегов **нельзя использовать пробелы и специальные символы**.
            - **Неправильно**:
                
                ```xml
                <book title="XML Guide"></book title>
                ```
                
            - **Правильно**:
                
                ```xml
                <book>
                  <title>XML Guide</title>
                </book>
                
                ```
                
        
        ### 4. **Чувствительность к регистру**
        
        - **Ошибка**: XML **чувствителен к регистру**, теги должны быть закрыты тем же регистром, что и открыты.
            - **Неправильно**:
                
                ```xml
                <Book>
                  <Title>XML Guide</title>
                </Book>
                
                ```
                
            - **Правильно**:
                
                ```xml
                
                <book>
                  <title>XML Guide</title>
                </book>
                
                ```
                
        
        ### 5. **Отсутствие атрибутов или неправильные атрибуты**
        
        - **Ошибка**: Значения атрибутов должны быть заключены в **кавычки**.
            - **Неправильно**:
                
                ```xml
                xmlКопировать код
                <book title=XML Guide></book>
                
                ```
                
            - **Правильно**:
                
                ```xml
                xmlКопировать код
                <book title="XML Guide"></book>
                
                ```
                
        
        ### 6. **Использование специальных символов без экранирования**
        
        - **Ошибка**: Специальные символы, такие как `<`, `>`, `&`, **нужно экранировать**.
            
            - **Неправильно**:
                
                ```xml
                <book>
                  <description>This is a guide to XML & HTML</description>
                </book>
                
                ```
                
            - **Правильно**:
                
                ```xml
                <book>
                  <description>This is a guide to XML &amp; HTML</description>
                </book>
                
                ```
                
        - Экранирование специальных символов:
            
            - `&` заменяется на `&amp;`
            - `<` заменяется на `&lt;`
            - `>` заменяется на `&gt;`
            - `"` заменяется на `&quot;`
            - `'` заменяется на `&apos;`
        
        ### 7. **Отсутствие декларации XML**
        
        - **Ошибка**: Декларация XML не является обязательной, но её часто рекомендуют добавлять.
            - Пример правильной декларации:
                
                ```xml
                <?xml version="1.0" encoding="UTF-8"?>
                
                ```
                
            - Это указывает версию XML и кодировку, которая используется в документе.
                
        
        ### 8. **Несбалансированные теги**
        
        - **Ошибка**: Все открытые теги должны быть закрытыми в правильном порядке.
            - **Неправильно**:
                
                ```xml
                <book>
                  <title>XML Guide</book>
                </title>
                
                ```
                
            - **Правильно**:
                
                ```xml
                
                <book>
                  <title>XML Guide</title>
                </book>
                
                ```
                
        
        ### 9. **Неиспользование самозакрывающихся тегов для пустых элементов**
        
        - **Ошибка**: Пустые элементы можно записывать с использованием **самозакрывающихся тегов**.
            - **Неправильно**:
                
                ```xml
                <image></image>
                
                ```
                
            - **Правильно**:
                
                ```xml
                
                <image />
                
                ```
                
        
        ### 10. **Нарушение структуры дерева**
        
        - **Ошибка**: XML должен иметь правильную иерархическую структуру, элементы должны быть корректно вложены друг в друга.
            - **Неправильно**:
                
                ```xml
                <book>
                  <title>XML Guide
                <author>John</author>
                </book>
                
                ```
                
            - **Правильно**:
                
                ```xml
                <book>
                  <title>XML Guide</title>
                  <author>John</author>
                </book>
                
                ```
                
        
        ---
        
        ### Основные правила для XML:
        
        1. **Один корневой элемент**: Весь документ должен быть заключен в один корневой элемент.
        2. **Правильная структура**: Элементы должны быть правильно вложены и закрыты.
        3. **Использование кавычек**: Атрибуты должны быть заключены в двойные кавычки.
        4. **Чувствительность к регистру**: Имена тегов и атрибутов чувствительны к регистру.
        5. **Экранирование символов**: Все специальные символы должны быть экранированы.
        6. **Пустые элементы**: Можно использовать самозакрывающиеся теги для пустых элементов.
        7. **Декларация XML**: Желательно начинать документ с декларации `<?xml version="1.0" encoding="UTF-8"?>`.
        
        ### Пример правильного XML:
        
        ```xml
        xmlКопировать код
        <?xml version="1.0" encoding="UTF-8"?>
        <bookstore>
          <book>
            <title lang="en">XML Guide</title>
            <author>John</author>
            <year>2024</year>
            <price>29.99</price>
          </book>
          <book>
            <title lang="en">HTML Guide</title>
            <author>Jane</author>
            <year>2023</year>
            <price>19.99</price>
          </book>
        </bookstore>
        
        ```
        
        Этот пример демонстрирует корректную структуру XML-документа с декларацией, корневым элементом, правильным использованием атрибутов, тегов и экранированием символов.
        
- Термин правила и ошибки вопросы.SQL
    
    ## **1)Что такое SQL и для чего он используется?**
    
    **Ответ:** SQL (Structured Query Language) — это язык программирования, используемый для управления и манипулирования реляционными базами данных. Он позволяет выполнять операции создания, чтения, обновления и удаления данных (CRUD) в базе данных, а также управлять её структурой.
    
    ## 2)Свойства транзакций в бд, известные под аббревиатурой **ACID**:
    
    - **Atomicity (Атомарность)**: Все операции внутри транзакции выполняются полностью или не выполняются вовсе.
    - **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое.
    - **Isolation (Изоляция)**: Результаты транзакции невидимы другим транзакциям до тех пор, пока транзакция не будет завершена.
    - **Durability (Долговечность)**: После завершения транзакции её результаты сохраняются, даже в случае сбоя системы.
    
    ### 3)Чатсые Ошибки SQL
    
    - **Ошибки** **sql**
        
        1. **Пропущенные или неправильные кавычки**
        
        ```php
        //Неправильно
        SELECT * FROM users WHERE name = John;
        //Правильно
        SELECT * FROM users WHERE name = 'John';
        ```
        
        2. **Ошибка с GROUP BY**
        
        ```php
        //1. Не все столбцы, не входящие в агрегатную функцию, должны быть в GROUP BY
        //Пример ошибки
        SELECT department, salary, COUNT(*) //salary по ней надо сделать агрегацию инначе будет ошибка
        FROM employees
        GROUP BY department; //Либо доавить в группировку GROUP BY department, salary
        ```
        
        3. **Ошибка с Join**
        
        ```php
        //Если таблицы содержат столбцы с одинаковыми именами, их нужно различать.
        //Ошибка
        SELECT id, name FROM users JOIN orders ON users.id = orders.user_id;
        //Правильно
        SELECT users.id, users.name, orders.order_date FROM users JOIN orders ON users.id = orders.user_id
        ```
        
    
    **4) Что подразумевается под СУБД? Какие существуют типы СУБД?**
    
    Система управления базами данных (СУБД)
    
    **Существует два типа СУБД:**
    
    - Реляционная система управления базами данных: данные хранятся в отношениях (таблицах). Пример — MySQL.
    - Нереляционная система управления базами данных: не существует понятия отношений, кортежей и атрибутов. Пример — Mongo.
    
    **5) В чем разница между типом данных CHAR и VARCHAR в SQL?**
    
    char(10) - только указыное количество символов, только 10
    
    varchar(10) - может хранить строку любой длинны но не больше 10
    
    **6) Из каких подмножеств состоит SQL?**
    
    **DML** _(Data Manipulation Language, язык управления данными)_
    
    DML-команды используются для работы с данными, уже находящимися в таблицах базы данных. Они управляют содержимым таблиц, изменяя записи, но не изменяют структуру таблиц.
    
    **Характеристики DML:**
    
    - Работает с содержимым таблиц, но не влияет на их структуру.
    - Может использоваться в транзакциях, поддерживает откат (`ROLLBACK`) и подтверждение (`COMMIT`).
    
    _**DDL** (Data Definition Language, язык описания данных)_ — команды используются для определения структуры базы данных. Они создают, изменяют или удаляют таблицы, индексы и другие объекты базы данных.
    
    **Характеристики DDL:**
    
    - Изменяет структуру базы данных, а не её содержимое.
    - Действия необратимы (например, удаление таблицы с помощью `DROP` нельзя откатить).
    - Автоматически выполняется как `COMMIT`, без возможности отката.
    
    _**DCL** (Data Control Language, язык контролирования данных)_ — позволяет контролировать доступ к базе данных. Пример — GRANT (предоставить права), REVOKE (отозвать права).
    
    **7)** **Что такое первичный ключ (Primary key)?**
    
    Это столбец или набор столбцов, которые однозначно идентифицируют каждую строку в таблице
    
    ) **Что такое внешний ключ (Foreign key)?**
    
    - Внешний ключ поддерживает ссылочную целостность, обеспечивая связь между данными в двух таблицах.
    - Внешний ключ в дочерней таблице ссылается на первичный ключ в родительской таблице.
    - Ограничение внешнего ключа предотвращает действия, которые разрушают связи между дочерней и родительской таблицами.
    
    **) Что подразумевается под целостностью данных?**
    
    ### 1. **Целостность сущности (Entity Integrity)**
    
    Этот тип целостности гарантирует, что каждый объект (сущность) в базе данных имеет уникальный идентификатор (например, первичный ключ), и что этот идентификатор не может быть `NULL`. То есть, каждая строка в таблице должна быть уникальной.
    
    **Целостность данных** в контексте баз данных — это принцип, который гарантирует точность, корректность и последовательность данных в базе данных на протяжении её жизненного цикла. Целостность данных помогает предотвратить ошибки, дублирование или потерю данных и обеспечивает, чтобы данные в базе всегда соответствовали заранее установленным правилам и ограничениям.
    
    - **Пример**: В таблице сотрудников каждый сотрудник должен иметь уникальный `id` (первичный ключ), и этот `id` не может быть пустым.
    
    ### 2. **Целостность отношений (Referential Integrity)**
    
    Этот тип целостности обеспечивает правильность ссылок между таблицами. Он гарантирует, что значения внешнего ключа в одной таблице соответствуют значениям первичного ключа в другой таблице. Если внешнему ключу присваивается значение, которого не существует в таблице, это нарушает целостность данных.
    
    - **Пример**: В таблице заказов есть столбец `customer_id`, который ссылается на `id` в таблице клиентов. Целостность данных требует, чтобы значение в `customer_id` существовало в таблице клиентов, и не должно быть заказов с несуществующими клиентами.
    
    ### 3. **Целостность домена (Domain Integrity)**
    
    Этот тип целостности гарантирует, что данные в каждом столбце соответствуют заранее определенному типу данных и диапазону значений. Например, если столбец предназначен для хранения дат, данные должны быть в формате даты. Также можно установить ограничения, такие как `CHECK`, чтобы данные соответствовали определённым критериям (например, возраст должен быть больше 18 лет).
    
    - **Пример**: Столбец `salary` в таблице сотрудников должен содержать только положительные числа. Он не может содержать строки или отрицательные значения.
    
    ### 4. **Целостность пользователя (User-Defined Integrity)**
    
    Этот тип целостности предполагает использование дополнительных бизнес-правил, которые могут быть определены пользователем для обеспечения правильности данных в базе. Это могут быть специфические ограничения, которые не охватываются другими типами целостности.
    
    - **Пример**: В магазине нельзя заказать больше товаров, чем есть в наличии. Это правило не является частью стандартных ограничений, но может быть реализовано с помощью триггеров или логики приложения.
    
    ### 5. **Целостность транзакций (Transaction Integrity)**
    
    Этот тип целостности подразумевает, что все операции с базой данных выполняются в рамках транзакций, которые обеспечивают атомарность, согласованность, изолированность и долговечность (ACID-принципы). Это гарантирует, что база данных всегда будет в корректном состоянии, даже в случае сбоев.
    
    - **Пример**: Если при выполнении транзакции по переводу средств из одного счета на другой произошел сбой, транзакция должна быть откатана, чтобы избежать ошибок или потери данных.
    
    )**В чем разница между кластеризованным и некластеризованным индексами в SQL? Можно сказать индексация столбцов**
    
    **Кластеризованный индекс**: Упорядочивает физически данные в таблице и может быть только один. Он обычно используется на столбце, который является первичным ключом. PRIMARY_KEY
    
    **Некластеризованные индексы**: Индексы, которые хранят указатели на данные, и могут быть созданы на нескольких столбцах. Они ускоряют поиск по этим столбцам, но не изменяют физический порядок данных в таблице. UNIQ_D34A04ADF9038C4
    
    **4)В чем разница между операторами DELETE и TRUNCATE**
    
    **TRUNCATE - не сможет удалить таблицу если у неё есть внешние ключи и тем более если не достпуно каскадное удаление**
    
    |DELETE|TRUNCATE|
    |---|---|
    |Используется для удаления строки в таблице|Используется для удаления всех строк из таблицы|
    |Вы можете восстановить данные после удаления|Вы не можете восстановить данные (прим. перевод.: операции логируются по разному, но в SQL Server есть возможность сделать откат) транзакции)|
    |DML-команда|DDL-команда|
    |Медленнее, чем оператор TRUNCATE|Быстрее|
    
    **)Объясните разницу между `INNER JOIN` и `OUTER JOIN`.**
    
    **Ответ:**
    
    - `OUTER JOIN` делится на три типа:
        
        - `LEFT OUTER JOIN` (или просто `LEFT JOIN`): возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, то поля из правой таблицы будут содержать `NULL`.
            - `INNER JOIN` возвращает только те строки, которые имеют совпадающие значения в обеих таблицах.
        - `RIGHT OUTER JOIN` (или `RIGHT JOIN`): возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, то поля из левой таблицы будут содержать `NULL`.
        - `FULL OUTER JOIN`: возвращает все строки, когда есть совпадения в одной из таблиц. Строки без совпадений получают `NULL` в соответствующих столбцах другой таблицы.
        
        **)Что такое сущности и отношения?**
        
        **Сущность** — это **таблица в базе данных**, где каждая строка представляет конкретный объект, а столбцы содержат его характеристики.
        
        **Отношение** — это связь между двумя (или более) сущностями. В реляционной модели данных отношения реализуются через первичные и внешние ключи.
        
        ### Типы отношений:
        
        1. **Один-к-одному (1:1)**:
            - Каждой записи одной сущности соответствует ровно одна запись другой сущности.
            - Пример: Пользователь и его профиль.
        2. **Один-ко-многим (1:N)**:
            - Одной записи одной сущности соответствует множество записей другой сущности.
            - Пример: Один пользователь может иметь несколько заказов.
        3. **Многие-ко-многим (M:N)**:
            - Каждая запись одной сущности может быть связана с несколькими записями другой сущности, и наоборот.
            - Пример: Студенты и курсы. Один студент может записаться на несколько курсов, а один курс может быть пройден несколькими студентами. Это реализуется через промежуточную таблицу.
            - Все столбцы содержат **однородные** данные (например, в одном столбце только числа, а не числа и строки вперемешку).
        
        )**Что такое индекс?Какие типы индексов есть?** Индексы относятся к методу настройки производительности, позволяющему быстрее извлекать записи из таблицы. Индекс создает отдельную структуру для индексируемого поля и, следовательно, позволяет быстрее получать данные.
        
        ### **Выбор правильного индекса**
        
        |Тип индекса|Когда использовать?|
        |---|---|
        |PRIMARY KEY|Уникальный идентификатор строки|
        |UNIQUE INDEX|Поля, которые должны быть уникальными|
        |CLUSTERED INDEX|Часто используемая сортировка данных|
        |NON-CLUSTERED|Часто выполняемые запросы на поиск|
        |FULLTEXT|Поиск по тексту (статьи, комментарии)|
        |SPATIAL INDEX|Геоданные (карты, координаты)|
        |BITMAP INDEX|Колонки с малым числом уникальных значений|
        |**Составной индекс**|Такой индекс может содержать более одного столбца.|
        |**Покрывающим** (covering index),|**Покрывающий индекс** — это индекс, который включает в себя все столбцы, нужные для выполнения запроса. Он помогает повысить производительность запросов, так как позволяет избежать обращения к таблице, но требует внимательного подхода к проектированию, чтобы не перегрузить систему слишком большими индексами.|
        
        Таблица не имеющая кластеризованного индекса называется кучей.
        
        Советы при проектирование индексов в таблице
        
        - Советы
            - Для таблиц которые часто обновляются используйте как можно меньше индексов.
            - Если таблица содержит большое количество данных, но их изменения незначительны, тогда используйте столько индексов, сколько необходимо для улучшение производительности ваших запросов. Однако хорошо подумайте перед использованием индексов на небольших таблицах, т.к. возможно использование поиска по индексу может занять больше времени, нежели простое сканирование всех строк.
            - Для кластеризованных индексов старайтесь использовать настолько короткие поля насколько это возможно. Наилучшим образом будет применение кластеризованного индекса на столбцах с уникальными значениями и не позволяющими использовать NULL. Вот почему первичный ключ часто используется как кластеризованный индекс.
            - Уникальность значений в столбце влияет на производительность индекса. В общем случае, чем больше у вас дубликатов в столбце, тем хуже работает индекс. С другой стороны, чем больше уникальных значения, тем выше работоспособность индекса. Когда возможно используйте уникальный индекс.
            - Для составного индекса возьмите во внимание порядок столбцов в индексе. Столбцы, которые используются в выражениях _WHERE_ (к примеру, _WHERE FirstName = 'Charlie'_) должны быть в индексе первыми. Последующие столбцы должны быть перечислены с учетом уникальности их значений (столбцы с самым высоким количеством уникальных значений идут первыми).
            - Также можно указать индекс на вычисляемых столбцах, если они соответствуют некоторым требованиям. К примеру, выражение которые используются для получения значения столбца, должны быть детерминистическими (всегда возвращать один и тот же результат для заданного набора входных параметров).
        
        Вопросы по индексам
        
        - Вопросы по индексам
            
            [https://habr.com/ru/articles/247373/](https://habr.com/ru/articles/247373/)
            
            **Почему таблица не может иметь два кластеризованных индекса?**
            
            Кластеризованный индекс – это и есть таблица.
            
            **Если кластеризованная таблица даёт множество преимуществ, то зачем использовать кучу?**
            
            Всё это означает, что вы должны рассматривать возможность использования кучи только когда работаете с особо-маленькими таблицами или всё ваше взаимодействие с таблицей ограничено вставкой данных и ваши запросы чрезвычайно просты. И так же если часто выполняете запросы диапазонов данных или запрашиваемые данные часто должны быть сортированы или сгруппированы.
            
            **Как изменить установленное по умолчанию значение коэффициента заполнения индекса?** в Mysql используеться OPTIMIZE TABLE
            
            **Какая взаимосвязь между ограничениями на уникальность значения и первичным ключом с индексами таблицы?**
            
            В общем случае, ограничение на уникальность значение и уникальный индекс это одно и то же.
            
            **Почему в SQL Server кластеризованные и некластеризованные индексы называются сбалансированным деревом?**
            
            Эти страницы организованы в виде определенной иерархии с древовидной структурой, называемой сбалансированным деревом.
            
            Если же это некластеризованный индекс, то лист индекса содержит указатель на кластеризованную таблицу или конкретную строку в куче
            
            ![изображение.png](attachment:7e222106-c836-419a-a2b2-f9a26cff41b9:%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5.png)
            
            **Если индексы настолько замечательны, то почему бы просто не создать их на каждый столбец?**
            
            Разумеется, индексы отлично себя показывают, пока вы выполняете запросы на выборку данных оператором _SELECT_, но как только начинается частый вызов операторов _INSERT_, _UPDATE_ и _DELETE. UPDATE AND DELETE Но что, если изменение приведет к разделению страниц, содержащих данные, или будет изменено значение ключевого столбца, приводящее к переносу его в другой индексный узел – это приведёт к тому, что индексу может потребоваться реорганизация, затрагивающая все связанные индексы и операции, в результате будет повсеместное падение производительности._ Касаемо оператора _INSERT_, главного врага всех индексов: вы начинаете добавлять большое количество данных, что приводит к изменению индексов и их реорганизации и все страдают.
            
            **Зачем использовать покрывающий индекс взамен составного индекса?**
            
            **Покрывающий индекс** — это индекс, который включает в себя все столбцы, нужные для выполнения запроса. Это индекс сохранит все столбцы которые нам нужны и мы сможем вызывая этот индекс мы можем не обращать к таблице получим все столюцы которые сохранились в этом индексе.И это главный плюс покрывающего индекса
            
        
        **Что такое нормализация и каковы ее преимущества?**
        
        Нормализация — процесс организации данных, цель которого избежать дублирования и избыточности. Некоторые из преимуществ:
        
        - Лучшая организация базы данных
        - Больше таблиц с небольшими строками
        - Эффективный доступ к данным
        - Большая гибкость для запросов
        - Быстрый поиск информации
        - Позволяет легко модифицировать
        - Проще реализовать безопасность данных
        - Сокращение избыточных и дублирующихся данных
        - Более компактная база данных
        - Обеспечивает согласованность данных после внесения изменений
        
        **Первая нормальная форма (1NF)** – Устранение повторяющихся групп Требование:
        
        - Пример нарушения 1NF
            
            |OrderID|Customer|Products|
            |---|---|---|
            |1|Иван|Телефон, Наушники|
            |2|Анна|Ноутбук|
            
            **Проблема:** колонка `Products` содержит несколько значений.
            
        - В каждой ячейке должно быть **одно** значение (атомарность данных).
            
        - Каждая строка таблицы должна иметь **уникальный идентификатор (первичный ключ)**.
            
        
        **Вторая нормальная форма (2NF)** – Устранение частичной зависимости от первичного ключа. Поле не с первичным ключом не должно зависить от первичного ключа. Уменьшение дубликатов так как таблица делиться на разные таблицы и уменьшается зависимость полей. П. С устранение зависимости от первичного ключа, поля которое не принадлежит этому первичному ключу
        
        - Пример нарушения 2NF
            
            Допустим, у нас есть таблица заказов с составным ключом (`OrderID, ProductID`):
            
            |OrderID|ProductID|ProductName|Customer|
            |---|---|---|---|
            |1|101|Телефон|Иван|
            |1|102|Наушники|Иван|
            |2|103|Ноутбук|Анна|
            
            **Проблема:** `ProductName` зависит **только от `ProductID`**, а не от всего ключа (`OrderID, ProductID`).
            
        - Таблица должна быть в **1NF**.
            
        - Каждый неключевой атрибут (столбец) **зависит от всего** первичного ключа, а не его части.
            
        
        **Третья нормальная форма (3NF)** – Устранение транзитивной зависимости
        
        - Пример нарушения 3NF
            
            |EmployeeID|Name|DepartmentID|DepartmentName|
            |---|---|---|---|
            |1|Олег|10|IT|
            |2|Анна|20|Маркетинг|
            
            **Проблема:** `DepartmentName` зависит не от `EmployeeID`, а от `DepartmentID`, создавая
            
        - Таблица должна быть в **2NF**.
            
        - Пример нарушения 4NF
            
            ### **Пример нарушения 4NF:**
            
            |StudentID|Course|Hobby|
            |---|---|---|
            |1|Математика|Футбол|
            |1|Математика|Шахматы|
            |1|Физика|Футбол|
            |1|Физика|Шахматы|
            
            **Проблема:** Курсы и хобби **не связаны друг с другом**, но зависят от `StudentID`, создавая **избыточность**
            
        - Все неключевые атрибуты должны зависеть **только от первичного ключа**, а не от других неключевых атрибутов
            
        
        **Четвёртая нормальная форма (4NF)** – Устранение многозначных зависимостей
        
        - Таблица должна быть в **3NF**.
        - В таблице **не должно быть многозначных зависимостей**, когда один ключ связан с несколькими независимыми наборами данных.
        
        **Пятая нормальная форма (5NF)** – Устранение зависимостей соединения
        
        - Пример нарушения 5NF
            
            |ProjectID|EmployeeID|SkillID|
            |---|---|---|
            |1|101|201|
            |1|102|202|
            |2|101|201|
            
            **Проблема:** Существуют **скрытые связи** между `ProjectID`, `EmployeeID` и `SkillID`.
            
        - Таблица должна быть в **4NF**.
            
        - Данные не должны зависеть от **разделяемых зависимостей**, которые могут быть разбиты на меньшие таблицы без потери информации.
            
        
        ### **)Какие существуют способы проектирование базы данных**
        
        [https://habr.com/ru/articles/193136/](https://habr.com/ru/articles/193136/) - **Руководство по проектированию реляционных баз данных. habr**
        
        [https://citforum.ru/database/osbd/contents.shtml](https://citforum.ru/database/osbd/contents.shtml) - **Основы современных баз данных. Книга Нормализация** — это процесс организации данных в базе для минимизации избыточности и зависимостей.
        
        **Денормализация -** это обратная сторона реализации. Может ускорить чтение, но могут усложнить обновление таблицы. Больше данных = больше затрат на хранение и обработку. Денормализация может затруднить масштабирование. Ваша бд начинает напоминать большой грузовичок, который сложно повернуть на новый путь.
        
        **Проектирование на основе использования -** Таблицы проектируются под реальные запросы, а не под строгие правила нормализации.
        
        **Проектирование по шаблонам** (Design Patterns)
        
        - **Звёздочная схема -** это тип схемы хранилища данных, который состоит из одной или нескольких таблиц фактов, ссылающихся на несколько таблиц, эта схема вращается вокруг центральной таблицы, называемой «таблицей фактов». Он окружен несколькими напрямую связанными таблицами, называемыми «таблицами измерений». Кроме того, существуют внешние ключи, которые связывают данные из одной таблицы в другую, устанавливая связь между ними с помощью первичного ключа другой таблицы.
            
            Таблица **фактов** содержит количественные данные, часто называемые мерами или метриками. Меры, как правило, числовые, такие как скорость, стоимость, количество и вес, и их можно агрегировать. Таблица **измерением** атрибуты, такие как сведения о продукте (название, категория, бренд), информация о клиенте (имя, адрес, сегмент), показатели времени (дата, месяц, год). Более того, четкое разграничение между измерениями и фактами позволяет пользователям легко анализировать информацию по различным измерениям. Это делает звездообразную схему также основополагающей моделью в приложениях бизнес-аналитики.
            
            ### **Преимущества:**
            
            - Простота: Легко понять и использовать.
            - Высокая производительность: Запросы, как правило, очень быстрые, так как они используют **индексы на столбцы измерений** и агрегируют данные в фактической таблице.
            - Простота в дизайне: Является стандартом для OLAP-систем.
            
            ### **Недостатки:**
            
            - Избыточность: В таблицах измерений часто дублируются данные.
            - Ограниченная гибкость: Не всегда подходит для сложных многозначных зависимостей.
        - **Снежинка схема -** это **усовершенствованная версия звёздочной схемы**. В отличие от звёздочной схемы, где таблицы измерений обычно денормализованы (содержат все данные в одной таблице), в снежинке таблицы измерений **нормализованы**. Это означает, что каждая таблица измерений может быть разделена на несколько других таблиц для улучшения структуры данных.
            
            **Таблицы измерений** нормализованы: каждое измерение может быть разделено на несколько таблиц.
            
            ### **Преимущества:**
            
            - **Меньше дублирования данных**, так как таблицы измерений нормализованы.
            - Более **гибкая структура**: Легко обновлять информацию, так как данные разделены на более мелкие таблицы.
            - Улучшение **целостности данных** за счет меньшего дублирования.
            
            ### **Недостатки:**
            
            - **Сложность запросов**: Запросы могут быть сложнее, так как нужно делать большее количество соединений.
            - **Производительность**: Может быть ниже, чем в звёздочной схеме, из-за необходимости выполнять дополнительные `JOIN`операции.
        - **Схема "Сущность-Атрибут-Значение"** (Entity-Attribute-Value, EAV) - Схема **EAV** используется для хранения данных, у которых структура может часто изменяться или содержать **динамические атрибуты**.
            
            ### **Преимущества:**
            
            - **Гибкость**: Легко добавлять новые атрибуты без необходимости изменять структуру таблиц.
            - **Меньше избыточности**: Характеристики хранятся в отдельных строках, а не в колонках.
            
            ### **Недостатки:**
            
            - **Сложность запросов**: Запросы могут быть сложными, так как для извлечения данных нужно делать дополнительные соединения и фильтровать по атрибутам.
            - **Проблемы с производительностью**: Из-за большого количества строк для каждого атрибута запросы могут быть медленными.
        
        шаблонов многов это можно изучать далее!!!
        
        **Проектирование с учётом индексов**
        
        **Суть:**Создание индексов для ускорения запросов.
        
        **Применение:** Большие базы данных с частыми Select
        
        **Минусы:** Индексы занимают место, замедляют
        
        **Key-Value (NoSQL-подход)**
        
        **Суть:** Данные хранятся в формате ключ-значение.
        
        **Применение:** Кэширование, распределённые системы, NoSQL (Redis, DynamoDB).
        
        **Минусы:** Нет строгой структуры, сложнее делать сложные запросы.
        
        **Плюсы:** Множество плюсов основные простой и гибкий
        
        **Документно-ориентированное проектирование**
        
        **Суть:**Данные хранятся как JSON-документы.
        
        **Применение:**MongoDB, Elasticsearch, приложения с гибкой схемой данных.
        
        **Минусы:**Сложно контролировать целостность, занимает больше места.
        
        ### **Что вы подразумеваете под «триггером» в SQL?**
        
        Триггер в SQL — особый тип хранимых процедур, которые предназначены для автоматического выполнения в момент или после изменения данных. Это позволяет вам выполнить пакет кода, когда вставка, обновление или любой другой запрос выполняется к определенной таблице.
        
        ### **Какие операторы доступны в SQL?**
        
        В SQL доступно три типа оператора, а именно:
        
        1. Арифметические Операторы
        2. Логические Операторы
        3. Операторы сравнения
        
        ### **Какие бывают типы подзапросов?**
        
        **Подзапросы в SELECT** (для выбора значений)
        
        **Подзапросы в WHERE** (для фильтрации данных)
        
        a) **Некоррелированный подзапрос**: Это подзапрос, который не зависит от внешнего запроса. Он выполняется только один раз, независимо от того, сколько строк в основном запросе.
        
        б) **Коррелированный подзапрос**: Коррелированный подзапрос зависит от внешнего запроса, то есть он ссылается на столбцы из основного запроса. Подзапрос выполняется для каждой строки внешнего запрос
        
        ```jsx
        SELECT product_name, price
        FROM products p
        WHERE price > (SELECT AVG(price) FROM products WHERE category = p.category);
        ```
        
        Здесь подзапрос использует столбец `category` из внешнего запроса (`p.category`) и выполняется для каждой строки основной таблицы.
        
        **Подзапросы в FROM** (для создания временных таблиц)
        
        **Подзапросы в HAVING** (для фильтрации групп)
        
        **Подзапросы** с операторами IN, EXISTS, ANY, ALL
        
        **Скалярные подзапросы**
        
        **Что такое обобщенное табличное выражение (CTE) и как оно используется?**
        
        Обобщенное табличное выражение (CTE) – это временно сохраненный в памяти результат табличных выражений, к которому можно обратиться повторно. Оно позволяет пользователю определить подзапрос, на который можно ссылаться несколько раз в рамках более крупного запроса.
        
        **Что такое оконная функция и как она используется?**
        
        Оконная функция – это тип функции в SQL, которая выполняет вычисления для набора строк в определенном “окне” или диапазоне. Она используется для решения сложных аналитических задач, которые не могут быть легко решены с помощью простых агрегатных функций.
        
        **В чем разница между транзакцией и batch?**
        
        В SQL транзакция - выполняються атомарно.
        
        С другой стороны, batch (пакет) – это набор операторов SQL, которые передаются в базу данных для выполнения в виде группы. В отличие от транзакций, пакеты не обеспечивают такого же уровня атомарности или гарантии согласованности.
        
        **В чем разница между скалярной и табличной функцией?**
        
        Скалярная функция возвращает одно значение.
        
        Табличная функция, с другой стороны, возвращает таблицу в качестве своего набора результатов.
        
- Вопросы и ответы по опереционные системы LINUX
    
    **Основные команды которые лучше знать.** [https://tproger.ru/articles/100-komand-linux-dlya-ezhednevnoj-raboty#one](https://tproger.ru/articles/100-komand-linux-dlya-ezhednevnoj-raboty#one)
    
    **Что такое Linux?**
    
    Linux — это операционная система или ядро, распространяемое по лицензии с открытым исходным кодом
    
    **Что такое bash?**
    
    **Bash** (Bourne Again SHell) — это командная оболочка, которая используется в UNIX-подобных операционных системах
    
    **Что такое ядро Linux?**
    
    **Ядро Linux** — это центральная часть операционной системы, которая взаимодействует с аппаратным обеспечением компьютера и предоставляет необходимые ресурсы для работы программного обеспечения. Оно управляет памятью, процессами, файловыми системами, устройствами ввода-вывода, а также предоставляет интерфейс для работы с пользовательскими программами. Предоставляет интерфейс между программами и железом
    
    **Что такое ЛИЛО?**
    
    **Загрузчик**: LILO — это **загрузчик**, который загружает ядро Linux в память и передает управление операционной системе.
    
    **Что такое пространство подкачки?**
    
    **Пространство подкачки** (или **swap** пространство) — это часть дискового пространства, которое используется операционной системой для хранения данных, когда оперативная память (RAM) исчерпана. Процесс подкачки позволяет системе продолжать работать, даже если физическая память полностью занята, хотя с меньшей производительностью, поскольку доступ к данным на жестком диске или SSD значительно медленнее, чем к данным в оперативной памяти.
    
    **Проект GNU! В чем важность проекта GNU?**
    
    Проект GNU имеет огромное значение в истории свободного программного обеспечения. Его философия, инструменты и лицензии значительно изменили программную индустрию, сделав доступ к высококачественному ПО более свободным и открытым для всех.
    
    **Опишите корневую учетную запись.?**
    
    Корневая учетная запись — это важнейшая часть системы управления в операционных системах Unix-подобного типа, предоставляющая полные административные привилегии. Однако из-за высокого уровня доступа к критическим частям системы она должна использоваться с осторожностью, чтобы избежать случайных ошибок и предотвратить угрозы безопасности.
    
    **Что такое CLI?**
    
    это интерфейс командной строки, который позволяет пользователю взаимодействовать с компьютером или операционной системой через ввод текстовых команд в терминале или консоли.
    
    **Про Память linux?**
    
    **** В Linux есть два основных типа памяти: **физическая память** (RAM) и **память подкачки** (swap). И еще есть Виртуальная память.
    
    **Что такое символические ссылки?**
    
    **Символическая ссылка** (или **symlink**) — это специальный файл в операционных системах UNIX и Linux, который указывает на другой файл или каталог в файловой системе. Это своего рода ярлык, который перенаправляет к целевому файлу или директории, позволяя использовать его как обычный файл, но без необходимости дублировать данные.**Создание символической ссылки**: Для создания символической ссылки используется команда `ln` с опцией `-s` . ln -s /путь/к/целевому/файлу /путь/к/ссылке
    
    **Что такое демоны?**
    
    **Демоны** в Linux — это фоны процессы, которые работают в фоне, часто в ответ на события или запросы, и не требуют активного взаимодействия с пользователем. Эти процессы обычно запускаются при старте системы и работают в течение всей работы системы, выполняя различные задачи, такие как обслуживание запросов, управление ресурсами или обеспечение сетевых сервисов.
    
    ### Основные характеристики демонов:
    
    1. **Фоновый процесс**: Демоны запускаются и работают в фоне, не требуют постоянного присутствия в терминале или пользовательского взаимодействия. Они выполняют свои задачи без вмешательства пользователя.
    2. **Постоянно работающие процессы**: Многие демоны начинают свою работу с момента старта операционной системы и продолжают работать до её завершения.
    3. **Отсутствие пользовательского интерфейса**: Демоны не предоставляют интерфейс для взаимодействия с пользователем. Они часто взаимодействуют с другими процессами или сервисами через системные вызовы, файлы логов или сети.
    4. **Запуск в фоновом режиме**: Демоны работают в фоне и обычно не требуют ввода с клавиатуры. Например, веб-сервер или база данных будет постоянно работать, обслуживая запросы.
    
    ### Примеры демонов:
    
    - **sshd** — демон, который управляет сетевыми подключениями через SSH (для удаленного доступа).
    - **httpd** или **nginx** — веб-серверы, которые обрабатывают HTTP-запросы и отправляют веб-страницы.
    - **cron** — демон, который управляет планировщиком задач, позволяя запускать команды или скрипты по расписанию.
    - **syslogd** — демон для обработки логов системы, который записывает события и ошибки, происходящие в системе.
    
    **Какие разрешения существуют в Linux?**
    
    В Linux права доступа играют важную роль в безопасности системы. Они позволяют администраторам системы и пользователям контролировать, кто может читать, писать или выполнять файлы, что критично для предотвращения несанкционированного доступа или повреждения данных.
    
    ### Основные принципы прав доступа:
    
    В Linux права доступа состоят из трех основных компонентов:
    
    1. **Типы пользователей** (User Categories)
    2. **Типы разрешений** (Permission Types)
    
    ### Типы пользователей
    
    3. **Специальные разрешения** (Special Permissions)
    
    Права доступа назначаются для трех категорий пользователей:
    
    4. **Владелец (User, `u`)** — пользователь, который является владельцем файла или каталога.
    5. **Группа (Group, `g`)** — группа пользователей, к которой принадлежит владелец файла или каталога. Это может быть группа, созданная для определенной цели (например, группа разработчиков).
    6. **Прочие (Others, `o`)** — все остальные пользователи, которые не являются владельцами и не входят в группу владельца.
    
    ### Типы разрешений
    
    Каждое разрешение может быть назначено для каждого из пользователей: владельца, группы и прочих.
    
    7. **Чтение (Read, `r`)** — позволяет читать содержимое файла или перечислять файлы в каталоге.
    8. **Запись (Write, `w`)** — позволяет изменять содержимое файла или добавлять/удалять файлы в каталоге.
    9. **Исполнение (Execute, `x`)** — позволяет запускать файл как программу или входить в каталог.
    
    ### Специальные разрешения
    
    **Setuid (Set User ID)**
    
    - **Тип**: используется для исполняемых файлов.
    - Когда установлено, процесс будет работать с правами владельца файла, а не с правами пользователя, который его запустил.
    
    **Setgid (Set Group ID)**
    
    - **Тип**: используется для файлов и каталогов.
    - Для **файлов**: процесс выполняется с правами группы владельца файла.
    - Для **каталогов**: все файлы, созданные в каталоге, будут иметь группу, соответствующую группе каталога.
    
    **Sticky Bit**
    
    - **Тип**: используется для каталогов.
    - Включает ограничение прав на удаление файлов: только владельцы файлов могут удалять свои файлы в каталоге (остальные пользователи не могут).
    - Обозначается как **`t`** в месте разрешений для **прочих** пользователей.
    - Обычно применяется в каталогах, например, в каталоге **`/tmp`**, где могут работать многие пользователи.
    
    **Основные аспекты переменных окружения?**
    
    1. **Хранение информации о системе:** Переменные окружения содержат данные, такие как пути к каталогам, настройки локализации, параметры конфигурации и т. д.
        1. **Доступность для процессов:** Переменные окружения доступны для всех запущенных процессов, что позволяет программам узнавать определенные настройки или переменные, влияющие на их поведение.
    2. **Группы GID (Group Identifier)** — уникальный идентификатор группы пользователя. В системах Linux каждый пользователь может быть членом нескольких групп, и для каждой группы существует свой GID. sudo usermod -aG docker dev - создание группы sudo chown :docker /path/to/file - дать доступ root для группы В итоги так можно создать группу, и добавить root права в эту группу
    3. **Пример переменных окружения:** Некоторые распространенные переменные окружения в Linux:
        - **`PATH`**: указывает список директорий, которые оболочка будет искать при выполнении команд.
        - **`HOME`**: указывает на домашний каталог текущего пользователя.
        - **`USER`**: имя текущего пользователя.
        - **`SHELL`**: путь к исполняемому файлу текущей оболочки.
        - **`LANG`**: используется для определения локализации системы (язык, формат даты и времени и т. д.).
        - **`PWD`**: текущий рабочий каталог.
        - **`EDITOR`**: предпочитаемый текстовый редактор.
    
    ### Тип файла в Linux:
    
    - — обычный файл (данные, текст, исполнимый файл).
    - **`d`** — каталог.
    - **`l`** — символическая ссылка.
    - **`c`** — символьное устройство.
    - **`b`** — блочное устройство.
    - **`p`** — именованный канал (FIFO).
    - **`s`** — сокет.
    
    **Что такое перенаправление?**
    
    **Перенаправление** в Linux — это процесс отправки вывода команды в другой файл или устройство, вместо того чтобы выводить его на экран (в терминал). Это важная часть работы с командной оболочкой, которая позволяет гибко управлять потоками ввода и вывода. Перенаправление позволяет более эффективно управлять выводом программ, записывать данные в файлы, создавать логи и обрабатывать ошибки. Это важный инструмент для автоматизации и скриптинга в Linux.
    
    **Что находится в /usr/local?**
    
    Он содержит локально установленные файлы. Этот каталог имеет значение в средах, где файлы хранятся в сети. В частности, локально установленные файлы располагаются в /usr/local/bin, /usr/local/lib и т. д.). Другое применение этого каталога заключается в том, что он используется для пакетов программного обеспечения, установленных из исходного кода, или для программного обеспечения, официально не поставляемого с дистрибутивом
    
    **Что такое UID?Какой он будет у администратара**
    
    **UID (User Identifier)** — это уникальный числовой идентификатор, присваиваемый каждому пользователю в операционной системе Linux или Unix-подобных системах. **Как посмотреть все файлы в каталоге, включая скрытые?**
    
    ls -a
    
    **Какая команда в Unix/Linux удаляет каталог со всем его содержимым?**
    
    rm -rf /home/user/my_folder
    
    - **`rm`** — команда для удаления файлов.
    - **`r`** (или **`-recursive`**) — опция для рекурсивного удаления, которая позволяет удалять не только файлы, но и каталоги с их содержимым.
    - **`f`** (или **`-force`**) — принудительное удаление, игнорируя предупреждения и ошибки
    
    **Как получить все переменные окружения и как их можно использовать?**
    
    env
    
    **Что означают права 0750 для файла?Что означают права 0750 для каталога?**
    
    Это означает то что у владельца есть права на чтение,запись,выполнение(фаила) - 7, а группы есть только доступ на чтение и выполнение 5
    
    Числовой способ - подсчет прав
    
    Каждое разрешение имеет числовое значение:
    
    - Чтение (r) = 4
        
    - Запись (w) = 2
        
    - Исполнение (x) = 1
        
    - **7** = r+w+x (4+2+1) - есть все права
        
    - **6** = r+w (4+2) - есть права на чтение запись
        
    - **5** = r+x (4+1) - есть права на чтение и исполнение
        
    - **4** = r (4) просто чтение
        
    - **3** = w+x (2+1)
        
    - **2** = w (2)
        
    - **1** = x (1)
        
    - **0** = нет прав (0)
        
    
    **Что делает `&` в конце команды?**
    
    Когда вы добавляете `&` в конце команды, она запускается асинхронно, и вы можете продолжать использовать терминал для ввода других команд, не дожидаясь завершения выполнения текущей команды.
    
    **Что делает `& disown` в конце команды?**
    
    В данном случаи можно даже закрыть терминал процесс будет продолжать
    
    **Что такое пакетный фильтр и как он работает?**
    
    **Пакетный фильтр (Packet Filter)** — это сетевой фильтр, который проверяет заголовки пакетов данных, проходящих через систему, чтобы определить, следует ли разрешить или отклонить их на основе заранее заданных правил. Он является основой для большинства брандмауэров и маршрутизаторов, обеспечивая фильтрацию трафика, исходя из атрибутов каждого пакета (например, IP-адреса, портов и протоколов.
    
    Таким образом, пакетные фильтры являются важной частью систем безопасности, защищая их от нежелательного или вредоносного трафика, но часто используются в комбинации с более сложными механизмами фильтрации, такими как **фильтрация по состоянию** или **прокси-серверы**.
    
    **Что такое A-запись, NS-запись, PTR-запись, CNAME-запись, MX-запись? очень кратко. Можно не учить**
    
    - **A-запись**: Связывает домен с IPv4-адресом (например, `example.com` → `192.0.2.1`).
    - **NS-запись**: Указывает на DNS-сервер, который управляет доменом (например, `example.com` → `ns1.example.com`).
    - **PTR-запись**: Используется для обратного разрешени еёя доменов, связывая IP-адрес с доменным именем (например, `192.0.2.1` → `example.com`).
    - **CNAME-запись**: Создает псевдоним для другого доменного имени (например, `www.example.com` → `example.com`).
    - **MX-запись**: Указывает на почтовый сервер для обработки электронной почты домена (например, `example.com` → `mail.example.com`).
    
    **Что такое Split-Horizon DNS?Это больше относиться к СЕТИ.**
    
    **Split-Horizon DNS** — это метод конфигурации DNS, который использует разные DNS-записи для разных типов клиентов в зависимости от их местоположения или сети. Это позволяет управлять разрешением имен для одной и той же зоны, но с разными результатами в зависимости от того, кто выполняет запрос (например, внутренний или внешний пользователь).
    
    - **Внутренние DNS-записи**: Внутри корпоративной сети, серверы могут быть доступны по специфическим именам или IP-адресам, которые не доступны извне.
    - **Внешние DNS-записи**: Для публичных пользователей или клиентов из Интернета, те же домены могут разрешаться в другие IP-адреса или даже на другие сервера.
    
    **Что такое sticky bit?**
    
    **Sticky bit** — это специальный бит разрешений, который используется в UNIX и Linux для управления доступом к файлам в общих каталогах, таких как временные директории (например, `/tmp`). **Что делает установленный на файл immutable bit?**
    
    **Immutable bit** (неизменяемый бит) — это специальный атрибут файлов в UNIX и Linux, который предотвращает любые изменения файла. Когда установлен immutable bit, файл становится **неизменяемым**, что означает, что его нельзя будет:
    
    - Изменить (например, с помощью редакторов или команд, таких как `vi` или `nano`).
    - Удалить.
    - Переименовать.
    - Переместить.
    
    **Какая разница между символическими и жесткими ссылками? Что произойдет если удалить символическую/жесткую ссылку?**
    
    |Характеристика|Жесткие ссылки|Символические ссылки|
    |---|---|---|
    |Указывает на **inode**|Да|Нет (указание на путь к файлу)|
    |Может быть создана для каталога|Нет (кроме суперпользователя)|Да|
    |Работает **через один и тот же файл**|Да (оба файла идентичны)|Нет (ссылку можно удалить, не затронув файл)|
    |Может ссылаться на файл в другой файловой системе|Нет|Да|
    |Удаление ссылки при удалении исходного файла|Нет (данные остаются, пока не удалена последняя ссылка)|Да (если ссылка указывает на несуществующий файл, она становится "битой")|
    |Влияет на пространство на диске|Не влияет на использование диска, только увеличивает количество ссылок|Влияет на пространство (создается отдельный файл-ссылка)|
    
    **Что такое inode и какая информация хранится в inode?**
    
    **Inode** (индексный узел) — это структура данных в файловой системе, которая хранит информацию о файле или каталоге, но **не** самих данных (содержимого) файла. Каждый файл или каталог в файловой системе имеет уникальный inode, который хранит метаданные о файле. **Получение inode файла**: Чтобы узнать номер inode файла, можно использовать команду `ls -i`:
    
    более сложные вопросы
    
    [https://www.guru99.com/ru/linux-interview-questions-answers.html](https://www.guru99.com/ru/linux-interview-questions-answers.html)
    
- Глава 1 основа тестирование
    
    1. Что такое тестирование?
        
        1. Тестирование - это сравнение фактического результат с ожидаемым.
    2. Модель разработки программного обеспечения (ПО)?
        
        1. Модель разработки программного обеспечения (ПО) — это структура или методология, которая определяет этапы, подходы и процессы создания программного продукта.
    3. Популярные модели разработки программного обеспечения (ПО)?Рассказать про один на выбор
        
        1. **Каскадная модель (Waterfall)(Водопадная)**
        
        Каскадная модель — это одна из первых моделей разработки ПО, основанная на линейной последовательной структуре. Каждый этап разработки должен быть завершен до начала следующего, и изменения на предыдущих этапах могут быть сложными и дорогостоящими.
        
        Этапы каскадной модели:
        
        - **Анализ требований**: сбор всех требований к системе. Этот этап критически важен, так как после его завершения изменение требований затруднительно.
        - **Проектирование**: создание архитектуры системы на основе собранных требований. Разрабатываются как общая архитектура, так и детализированные компоненты.
        - **Реализация (кодирование)**: разработка программного кода на основании проектных решений.
        - **Тестирование**: проверка кода на соответствие требованиям. На этом этапе проводятся функциональные и нефункциональные тесты.
        - **Внедрение**: развертывание продукта на рабочем окружении.
        - **Поддержка и сопровождение**: устранение ошибок, улучшение производительности, обновление системы.
        
        **Преимущества:**
        
        - Четкая структура и последовательность.
        - Хорошо подходит для проектов с неизменными требованиями.
        
        **Недостатки:**
        
        - Трудно вносить изменения на поздних этапах.
        - Задержки могут быть из-за строгой последовательности этапов.
        - Подходит для проектов с полным и четким набором требований.
        
        б. **Итерационная модель**
        
        Итерационная модель предусматривает разработку ПО циклическими этапами. В каждой итерации создается полноценный рабочий продукт, который может быть доработан на следующих итерациях. Итерации идут по кругу до тех пор, пока не будет достигнут окончательный результат.
        
        Этапы:
        
        - **Планирование**: определяются цели для текущей итерации.
        - **Проектирование и реализация**: разработка и внедрение функциональности.
        - **Тестирование**: проверка продукта на соответствие требованиям.
        - **Анализ**: обратная связь с заказчиком и внесение изменений в требования для следующей итерации.
        
        **Преимущества:**
        
        - Гибкость и возможность корректировки требований на каждом этапе.
        - Поставки частичных, но полноценных версий продукта.
        - Улучшенная управляемость рисками.
        
        **Недостатки:**
        
        - Могут быть трудности с точным определением сроков завершения проекта.
        - Требуются частые взаимодействия с заказчиком для обратной связи.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/9d28e6ba-8235-42eb-8287-f4c065d7ae9f/image.png)
    
    в.**V-образная модель**
    
    V-образная модель — это расширение каскадной модели с акцентом на тестирование на каждом этапе разработки. Основная идея в том, что разработка и тестирование идут параллельно, и каждый этап проектирования или реализации сопровождается соответствующим тестированием.
    
    Этапы:
    
    - **Анализ требований**: изучение требований к системе.
    - **Проектирование системы**: создание архитектуры системы.
    - **Детализированное проектирование**: детализация проектных решений.
    - **Реализация**: написание кода.
    - **Модульное тестирование**: тестирование отдельных модулей.
    - **Интеграционное тестирование**: тестирование взаимодействия между модулями.
    - **Системное тестирование**: проверка всей системы в целом.
    - **Приемочное тестирование**: проверка соответствия системы бизнес-требованиям.
    
    **Преимущества:**
    
    - Четкое разделение на фазы разработки и тестирования.
    - Подходит для проектов с четкими требованиями и малым риском изменений.
    
    **Недостатки:**
    
    - Трудности с внесением изменений после начала разработки.
    - Время на тестирование может быть большим.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/011aff52-413e-48ae-a130-de9bbecf9794/image.png)
    
    г. **Спиральная модель**
    
    Спиральная модель объединяет элементы каскадной и итерационной моделей, с особым акцентом на управление рисками. Процесс разработки проходит по спирали, на каждом витке которой выполняются планирование, анализ рисков, проектирование, разработка и тестирование.
    
    Этапы:
    
    - **Определение целей**: планирование целей каждой итерации.
    - **Идентификация и анализ рисков**: на каждом витке выявляются и минимизируются риски.
    - **Проектирование и разработка**: разработка функциональности с учетом выявленных рисков.
    - **Тестирование**: проверка продукта на соответствие требованиям.
    - **Оценка и планирование**: пересмотр целей и планов для следующей итерации.
    
    **Преимущества:**
    
    - Хорошо подходит для сложных и масштабных проектов.
    - Учитывает риски на каждом этапе.
    - Гибкость в планировании и разработке.
    
    **Недостатки:**
    
    - Сложность в управлении.
    - Высокие затраты на планирование и управление рисками.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/62e6d7cc-ee76-481d-8663-67b3107e07cd/image.png)
    
    д. **Agile**
    
    Agile — это гибкий подход к разработке ПО, который направлен на ускорение процесса, тесное взаимодействие с заказчиком и постоянную адаптацию к изменениям. Agile ориентирован на создание продукта в небольших, но ценных выпусках (итерациях).
    
    **В Agile продукт создается серийно, когда каждая последующая версия работоспособного решения имеет больше функциональных возможностей, чем предыдущая**
    
    ### Основные принципы Agile:
    
    - **Клиент на первом месте**: тесное взаимодействие с заказчиком на всех этапах.
    - **Итеративный процесс**: разработка продукта небольшими частями, с возможностью внесения изменений.
    - **Гибкость**: готовность к изменениям требований на любом этапе разработки.
    - **Кросс-функциональные команды**: команды разработчиков, тестировщиков и бизнес-аналитиков работают совместно для достижения целей.
    
    Agile включает несколько популярных методологий, такие как Scrum и Kanban.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/bc705c18-7af0-4c3e-89f4-6d88ee0a8faf/image.png)
    
    Принципы: Agile не самое важное но желательно знать nn |BVCXZ
    
    Эти идеи раскрываются в **12 принципах Agile** **Manifesto** **[1]**:
    
    1. работающий конкурентоспособный продукт, удовлетворяющий заказчика — лучший показатель прогресса и измеритель эффективности;
    2. оперативная и бесперебойная поставка продукта, удовлетворяющего заказчика;
    3. адаптивность продукта к новым требованиям, которые могут повысить его ценность и конкурентоспособность (возможность внесения изменений на любом этапе разработки);
    4. простота и прозрачность технических решений, документации, процессов и инструментов, чтобы не создавать лишней работы;
    5. частая поставка функционирующего продукта (раз в месяц/неделю или ещё чаще);
    6. постоянный темп работы всех участников проекта на протяжении всего его срока;
    7. минимизация организационных и информационных барьеров, лучший путь передачи информации — это личный разговор лицом к лицу;
    8. тесное и ежедневное общение исполнителей с заказчиком в течении всего проекта;
    9. мотивация участников проекта и обеспечение их всеми необходимыми условиями работы, поддержкой и доверием;
    10. самоорганизация и самоконтроль команды проекта;
    11. непрерывное улучшение профессиональных компетенций команды проекта;
    12. систематический анализ и постоянный поиск возможностей оптимизации командной и индивидуальной работы.
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/7a0152e2-1110-4ada-891c-a681b1531589/image.png)
    
    [https://bigdataschool.ru/wiki/agile](https://bigdataschool.ru/wiki/agile) - Очень подробно
    
    Методы и средства реализации(Scrum и Kanban)
    
    Кратко о скраме:
    
    В **Scrum** над проектом работает команда профильных технических специалистов **(например, аналитик, программист, тестировщик, администратор**) вместе с владельцем продукта (product owner) и модератором (scrum-мастер). Product owner аккумулирует бизнес-требования, соединяет команду исполнителей с заказчиком и следит за развитием проекта. Scrum-мастер управляет процессом организации разработки по Agile-принципам: проводит общие собрания (meetings, митинги), мотивирует и поддерживает команду.
    
    В Scrum рабочий процесс делится на равные периоды **от 1 до 4-х недель (спринты)**, в зависимости от проекта и команды. Перед стартом каждого спринта на митинге формулируются его задачи, а в конце обсуждаются результаты. Краткосрочность и измеряемость спринтов позволяет эффективно управлять проектной деятельностью, не перегружая участников проекта авралами **[4]**.
    
    Роли в Scrum:
    
    - **Product Owner (владелец продукта)**: определяет приоритеты задач, формирует требования.
    - **Scrum Master**: координирует работу команды, устраняет препятствия.
    - **Команда разработки**: непосредственно занимается созданием продукта.
    
    Процесс Scrum включает:
    
    - **Планирование спринта**: на этом этапе выбираются задачи из бэклога (списка задач).
    - **Ежедневные стендапы (Daily Standup)**: краткие ежедневные встречи, на которых обсуждаются текущие задачи и возможные проблемы.
    - **Ретроспектива спринта**: анализ проделанной работы и выявление путей улучшения на будущее.
    
    **Преимущества Scrum:**
    
    - Быстрая адаптация к изменениям.
    - Прозрачность и четкость в управлении.
    - Высокий уровень вовлеченности команды.
    
    **Недостатки:**
    
    - Требует строгой дисциплины и четкого выполнения процессов.
    - Может быть неэффективен для проектов с неопределенными требованиями
    
    Кратко канбан:
    
    В отличие от Scrum, в команде **канбан** отсутствуют роли владельца продукта и модератора, а процесс разработки делится не на универсальные спринты, а на стадии выполнения задач («Планируется», «Разрабатывается», «Тестируется», «Завершено»). Жизненный цикл задачи отображается на канбан-доске, физической или электронной. Такая визуализация делает рабочий процесс открытым и понятным для всех участников, что особенно важно в Agile, когда у команды нет одного формального руководителя.
    
    Канбан, как и другие практики бережливого производства, пришедшие из Японии, направлен на достижение баланса и выравнивание нагрузки исполнителей. Эффективность работы оценивается по среднему времени жизни задачи, от начальной до конечной стадии. Если задача прошла весь путь быстро, то команда проекта работала продуктивно и слаженно. Иначе – необходимо решать проблему: искать, где и почему возникли задержки и чью работу надо оптимизировать **[4]**.
    
    ![](https://bigdataschool.ru/wp-content/uploads/2019/07/%D0%B0%D0%B38.png)
    
    Задачи на Канбан-доске
    
    Сегодня наблюдается некоторое слияние Scrum и Kanban, например, канбан-доски стали практически обязательным элементом популярных систем управления проектами (Jira, Trello, Битрикс.24, Basecamp, Мегаплан и т.д.), которые, в том числе, поддерживают методологию скрам **[5]**.
    
    ### **Kanban**
    
    Kanban — это методология управления, которая ориентирована на визуализацию процесса работы и постоянное улучшение. Основная идея Kanban заключается в ограничении количества одновременно выполняемых задач, чтобы минимизировать задержки.
    
    Основные принципы Kanban:
    
    - **Визуализация потока работы**: задачи отображаются на доске, которая разделена на этапы (например, "В работе", "Тестирование", "Готово").
    - **Ограничение работы в процессе**: вводится ограничение на количество задач, которые могут одновременно находиться в работе.
    - **Управление потоком**: команды отслеживают время выполнения каждой задачи, чтобы выявлять и устранять узкие места.
    - **Постоянные улучшения**: команда постоянно работает над оптимизацией процесса.
    
    **Преимущества Kanban:**
    
    - Простота в использовании и гибкость.
    - Позволяет визуально оценивать загруженность команды и эффективность работы.
    - Удобен для проектов с постоянно меняющимися требованиями.
    
    **Недостатки:**
    
    - Меньший акцент на командную работу по сравнению с Scrum.
    - Не всегда ясно, как долго будет длиться выполнение задач.
    
    1. Жизненный цикл тестирования какие есть этапы?
        
        1. [https://vladislaveremeev.gitbook.io/qa_bible/sdlc-i-stlc/zhiznennyi-cikl-testirovaniya-po-stlc-software-testing-lifecycle](https://vladislaveremeev.gitbook.io/qa_bible/sdlc-i-stlc/zhiznennyi-cikl-testirovaniya-po-stlc-software-testing-lifecycle) - подробная информация
        
        ### **Жизненный цикл тестирования(Анализ требований, планирование тестирование, проектирование тестов, выполнение тестов, оценка тестов, отчет тестирование)**.
        
        Жизненный цикл тестирования программного обеспечения (Software Testing Life Cycle, STLC) — это процесс, состоящий из нескольких этапов, на каждом из которых проводятся определенные виды тестирования и выполняются специфические задачи. STLC включает планирование, проектирование, выполнение тестов, а также оценку результатов для обеспечения качества программного продукта.
        
        Основные этапы жизненного цикла тестирования:
        
        ### 1. **Анализ требований**
        
        На этом этапе команда тестировщиков анализирует функциональные и нефункциональные требования, предоставленные командой разработки или бизнес-аналитиками. Основная цель — определить, что необходимо протестировать, и выявить тестируемость требований.
        
        **Основные задачи:**
        
        - Анализ требований на полноту и ясность.
        - Определение тестовых сценариев и тест-кейсов, необходимых для покрытия всех аспектов требований.
        - Взаимодействие с разработчиками и бизнес-аналитиками для прояснения требований.
        
        **Выходные артефакты:**
        
        - Отчет о тестируемости требований.
        - Список вопросов и уточнений по требованиям.
        
        ### 2. **Планирование тестирования**
        
        На этапе планирования создается стратегия тестирования, включающая определение целей, объема тестирования, подходов, инструментов и графика. Также на этом этапе рассчитываются затраты и распределяются ресурсы.
        
        **Основные задачи:**
        
        - Определение объема тестирования (что будет и что не будет тестироваться).
        - Выбор методов тестирования (ручное или автоматизированное, виды тестирования).
        - Определение критериев готовности (начало) и завершения (окончание) тестирования.
        - Оценка рисков и разработка планов их снижения.
        
        **Выходные артефакты:**
        
        - План тестирования (Test Plan).
        - Оценка необходимых ресурсов и инструментов.
        - Определение временных рамок и бюджета на тестирование.
        
        ### 3. **Проектирование тестов**
        
        На этом этапе создаются тест-кейсы и тестовые сценарии на основе требований и стратегии тестирования. Важным моментом является подготовка тестовых данных и настройка среды для проведения тестов.
        
        **Основные задачи:**
        
        - Разработка тест-кейсов, которые покрывают все функциональные и нефункциональные требования.
        - Определение входных данных для тестирования и подготовка тестовой среды.
        - Рецензирование и проверка тест-кейсов, чтобы убедиться, что они корректны и полно покрывают требования.
        - Создание или обновление автоматизированных тестов, если применяется автоматизация.
        
        **Выходные артефакты:**
        
        - Тест-кейсы и тестовые сценарии (Test Cases).
        - Тестовые данные (Test Data).
        - Подготовленная тестовая среда.
        
        ### 4. **Выполнение тестов**
        
        На этапе выполнения тестирования запускаются тесты в соответствии с планом и тест-кейсами, которые были разработаны ранее. По результатам тестов фиксируются дефекты, и они передаются на исправление команде разработчиков.
        
        **Основные задачи:**
        
        - Выполнение ручных или автоматизированных тестов.
        - Логирование и документирование всех обнаруженных дефектов и сбоев.
        - Перепроверка исправленных дефектов (ретест) и тестирование, чтобы убедиться, что изменения не повлияли на другие части системы (регрессионное тестирование).
        
        **Выходные артефакты:**
        
        - Протоколы выполнения тестов (Test Execution Reports).
        - Список обнаруженных дефектов и багов.
        - Результаты ретеста и регрессионного тестирования.
        
        ### 5. **Оценка завершения тестирования**
        
        Этот этап включает в себя анализ всех выполненных тестов, проверку на соответствие критериям завершения, и подготовку итоговых отчетов о проведенном тестировании. Также проводится анализ качества системы и процесса тестирования.
        
        **Основные задачи:**
        
        - Сравнение фактических результатов тестирования с запланированными (покрытие тестов, количество дефектов, время выполнения).
        - Оценка качества продукта и готовности к выпуску.
        - Проведение пост-мортем анализа, чтобы выявить слабые стороны в процессе тестирования и предложить улучшения.
        
        **Выходные артефакты:**
        
        - Отчет о тестировании (Test Summary Report).
        - Пост-мортем отчет (Post-Mortem Report).
        - Принятие решения о завершении тестирования.
        
        ### 6. **Закрытие тестирования(Отчет)**
        
        Последний этап жизненного цикла тестирования включает документирование завершения тестирования, архивирование всех артефактов и проведение финальных оценок эффективности процесса. Может включать оценку обучения команды, использования инструментов и процесса управления.
        
        **Основные задачи:**
        
        - Архивирование тест-кейсов, отчетов и дефектов для будущего использования.
        - Проведение финальных собраний для анализа эффективности тестирования.
        - Выводы о том, какие аспекты процесса требуют улучшений.
        
        **Выходные артефакты:**
        
        - Закрытие отчетов по тестированию.
        - Выводы по улучшению процессов тестирования в будущем.
    2. Какие виды требование вы знаете? (виды требования)
        
        ### Основные виды требований:
        
        1. **Функциональные требования**
            
            Описывают, что система должна делать. Это основные задачи, которые система обязана выполнять для удовлетворения запросов пользователей.
            
            - Пример: "Пользователь должен иметь возможность зарегистрироваться на платформе."
        2. **Нефункциональные требования**
            
            Описывают, как система должна работать, включая такие аспекты, как производительность, безопасность, удобство использования, масштабируемость и надежность.
            
        
        - Пример: "Система должна обеспечивать отклик не более 2 секунд при загрузке страницы."
        
        1. **Бизнес-требования**
            
            Высокоуровневые цели, которых компания стремится достичь с помощью проекта. Они направлены на решение определенной бизнес-проблемы или выполнение бизнес-целей.
            
            - Пример: "Повысить конверсию пользователей на 15% через интеграцию новой функциональности."
        2. **Системные требования**
            
            Технические спецификации, касающиеся работы системы на уровне инфраструктуры. Включают требования к операционным системам, оборудованию, базам данных и другим элементам.
            
            - Пример: "Приложение должно работать на операционных системах Windows и macOS."
        3. **Пользовательские требования**
            
            Описывают потребности и ожидания конечных пользователей относительно системы. Они включают в себя функции, которые пользователи хотели бы видеть в продукте, а также аспекты, касающиеся удобства использования и взаимодействия с системой.
            
            - Пример: "Пользователь должен иметь возможность восстановить пароль через email, если он его забыл."
        4. **Ограничения**
            
            Это рамки или условия, которые влияют на процесс разработки, такие как временные, ресурсные, технологические и нормативные ограничения.
            
    3. Основные проблемы, связанные с требованиями?
        
        1. **Неясные или неполные требования**
            - Это одна из самых распространенных причин неудачи проектов. Если требования плохо документированы или недостаточно конкретны, разработчики могут неверно понять задачи или неправильно оценить объем работы.
        2. **Частые изменения требований**
            - Требования могут изменяться в процессе разработки, что создает дополнительную нагрузку на команду. Если изменения не контролируются, проект может превысить бюджет и выйти за рамки сроков.
        3. **Невозможность реализации требований**
            - Иногда требования могут быть технически невыполнимы или экономически невыгодны. Это обычно происходит, если заказчики или бизнес-аналитики не согласовывают их с разработчиками на ранних стадиях.
        4. **Игнорирование нефункциональных требований**
            - Если не уделять достаточно внимания нефункциональным аспектам, таким как производительность или безопасность, это может привести к тому, что система не сможет справиться с нагрузками или будет подвержена уязвимостям.
        
        принципа тестирования:
        
        5. **Тестирование демонстрирует наличие дефектов (Testing shows presence of defects)**: Тестирование может выявить ошибки в программном обеспечении, но не может доказать их отсутствие. Даже если тесты не нашли дефектов, это не означает, что система безошибочна.
        6. **Исчерпывающее тестирование недостижимо (Exhaustive testing is not possible)**: Проверить все возможные комбинации входных данных и условий невозможно. Вместо этого используется стратегия выборочного тестирования для охвата наиболее важных и вероятных сценариев.
        7. **Раннее тестирование (Early testing)**: Тестирование должно начинаться как можно раньше в жизненном цикле разработки. Это помогает выявить дефекты на ранних стадиях, когда их исправление обходится дешевле.
        8. **Скопление/кластеризация дефектов (Defect clustering)**: Обычно большинство дефектов сосредоточено в нескольких модулях или компонентах системы. Это явление известно как кластеризация дефектов.
        9. **Парадокс (эффект) пестицида (Pesticide paradox)**: Если одни и те же тесты повторять снова и снова, они перестанут находить новые дефекты. Чтобы оставаться эффективными, тесты необходимо регулярно обновлять и разнообразить.
        10. **Тестирование зависит от контекста (Testing is context dependent)**: Методы и подходы к тестированию зависят от типа системы, её критичности и условий использования. Например, тестирование финансового ПО будет отличаться от тестирования видеоигры.
        11. **Заблуждение об отсутствии ошибок (Absence of errors fallacy)**: Даже если программное обеспечение проходит все тесты без ошибок, это не гарантирует, что оно удовлетворяет требованиям пользователей или решает их задачи.
    4. Практики управления требованиями! Какие есть?
        
        ### **Четкая документация**
        
        - Все требования должны быть тщательно документированы и структурированы. Это помогает избежать недоразумений и облегчает процесс внесения изменений.
        
        1. **Валидация требований**
            - Требования должны быть проверены на предмет их соответствия бизнес-целям и технической возможности. Это позволяет выявить потенциальные проблемы на ранней стадии.
        2. **Приоритизация**
            - Классифицировать их по приоритету, чтобы команда сосредоточилась на реализации самых критичных задач.
        3. **Использование методологий Agile и DevOps**
            - В гибких методологиях, таких как Scrum, требования могут изменяться в процессе разработки. Это позволяет быстрее адаптироваться к новым условиям, но требует дисциплинированного управления и четкой коммуникации между командами.
        4. **Прототипирование и демонстрации**
            - На ранних стадиях разработки полезно создавать прототипы и демонстрировать их заказчикам. Это помогает убедиться в том, что требования правильно поняты, и позволяет внести коррективы до начала основной фазы разработки.
    5. Свойства качественных требований?
        
        ### Свойства качественных требований:
        
        1. **Полнота (Completeness)**
            - Требование должно быть полным и содержать все необходимые детали, чтобы разработчики и другие участники проекта могли точно понять, что требуется. Неполные требования могут привести к недопониманию и возникновению проблем на этапе реализации.
            - Пример: В требовании должно быть указано, не только что нужно добавить функцию регистрации, но и какие поля будут обязательными, каким образом будет проходить валидация данных, и что произойдет после успешной регистрации.
        2. **Однозначность (Unambiguity)**
            - Требования должны быть четкими и не оставлять места для разночтений или двусмысленности. Все термины должны быть однозначно определены, чтобы каждая сторона проекта (разработчики, тестировщики, заказчики) трактовала их одинаково.
            - Пример: В требовании не должно быть формулировок вроде "система должна работать быстро". Вместо этого следует указать конкретные параметры производительности (например, "время отклика не более 2 секунд").
        3. **Трассируемость** — это способность отслеживать и связывать различные элементы тестирования с их исходными требованиями и спецификациями.
        4. **Проверяемость (Verifiability)**
            - Требование должно быть сформулировано таким образом, чтобы его выполнение можно было проверить через тестирование или другие способы верификации. Оно должно содержать конкретные критерии, по которым можно однозначно определить, выполнено ли оно.
            - Пример: Требование "система должна поддерживать до 1000 одновременных пользователей" можно проверить с помощью нагрузочного тестирования.
        5. **Необходимость (Necessity)**
            - Каждое требование должно быть действительно необходимым для достижения целей проекта. Не должно быть "лишних" или "необязательных" требований, которые не вносят вклад в функциональность или качество системы.
            - Пример: Не включать в проект избыточные функции, которые могут усложнить систему и увеличить время и стоимость разработки, если они не критически важны для бизнеса.
        6. **Последовательность (Consistency)**
            - Все требования должны быть согласованы друг с другом и не противоречить. Внутренняя согласованность исключает ситуацию, при которой выполнение одного требования делает невыполнимым другое.
            - Пример: Если в одном требовании указано, что система должна поддерживать определенный интерфейс для взаимодействия, в другом требовании не должно быть требования о несовместимости с этим интерфейсом.
        7. **Реализуемость (Feasibility)**
            - Требования должны быть реализуемыми в рамках заданных временных, ресурсных и технологических ограничений. Если требование технически невыполнимо или слишком сложно для реализации в заданных условиях, оно должно быть пересмотрено.
            - Пример: Требование создать систему, которая поддерживает миллионы пользователей, может быть нереализуемо без серьезных инвестиций в инфраструктуру. Это необходимо учесть при планировании.
        8. **Измеримость (Measurability)**
            - Требование должно содержать четкие количественные критерии, которые можно измерить. Это позволяет точно оценить, выполнено ли требование и насколько система соответствует заявленным характеристикам.
            - Пример: Время ответа системы должно составлять не более 1 секунды при 1000 одновременных запросах. Такой параметр можно измерить и проверить.
        9. **Модифицируемость (Modifiability)**
            - Требования должны быть легко изменяемыми и расширяемыми в случае необходимости. Хорошо структурированное требование позволяет вносить изменения без нарушения всей структуры.
            - Пример: Структура требований должна позволять добавлять или изменять отдельные функции системы без кардинальных изменений других компонентов.
        10. **Атомарность (Atomicity)**
            - Каждое требование должно быть атомарным, то есть описывать одну конкретную функцию или аспект системы. Это позволяет избежать путаницы и делает требования более понятными и удобными для работы.
            - Пример: "Пользователь должен иметь возможность восстановить пароль и изменить профиль" — это два отдельных требования, их нужно разделить.
        11. Завершенность - требование является полным и законченным с точки зрения представления в нём всей необходимой информации, ничто не пропущено по соображениям «это и так всем понятно».
        
        ---
        
    6. Какие есть модули?:
        
        ### **1.Высокоуровневые модули (High-Level Modules)**
        
        **Высокоуровневые модули** работают на более абстрактном уровне и ближе к конечным пользователям или бизнес-логике системы. Эти модули отвечают за управление процессами на уровне приложений и взаимодействие с пользовательскими интерфейсами, предоставляя высокоуровневые функции и сервисы.
        
        ### Характеристики:
        
        - **Высокая абстракция**: Обрабатывают задачи на уровне бизнес-логики или взаимодействия с пользователем, избегая деталей внутренней работы системы.
        - **Используют низкоуровневые модули**: Взаимодействуют с низкоуровневыми модулями для выполнения более детализированных операций, таких как работа с памятью, сетью или файловой системой.
        - **Примеры**:
            - Модуль управления пользовательским интерфейсом (UI).
            - Системы принятия решений на основе данных.
            - Программные интерфейсы (API), которые предоставляют высокоуровневый доступ к функционалу системы.
        
        ### Пример:
        
        В приложении для электронной коммерции модуль, который управляет процессом оформления заказа и взаимодействует с корзиной покупок, является высокоуровневым модулем. Он использует низкоуровневые модули для обработки запросов к базе данных, валидации платежей и управления товарами.
        
        ---
        
        ### 2. **Низкоуровневые модули (Low-Level Modules)**
        
        **Низкоуровневые модули** работают на уровне конкретных технических деталей системы, обеспечивая выполнение задач, которые требуют прямого доступа к системным ресурсам или детализированных операций.
        
        ### Характеристики:
        
        - **Низкая абстракция**: Обеспечивают выполнение специфичных операций, таких как работа с памятью, файловыми системами, сетевыми протоколами и железом (аппаратной частью).
        - **Используются высокоуровневыми модулями**: Они предоставляют высокоуровневым модулям интерфейсы для выполнения низкоуровневых задач.
        - **Примеры**:
            - Модули драйверов для управления аппаратным обеспечением.
            - Модули работы с сетью, операционной системой или файловой системой.
            - Модули для работы с базами данных.
        
        ### Пример:
        
        В системе электронной коммерции низкоуровневым модулем может быть модуль для выполнения SQL-запросов к базе данных, который предоставляет функции для добавления, изменения и удаления записей о заказах и клиентах.
        
    7. Классификация тестирование. Какие есть?
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/13d8613e-3202-4987-b1df-e976f7d6cc73/image.png)
        
    8. Виды тестирование. Какие есть виды тестирование?
        
        # Мобильное тестирование
        
    9. **Типы мобильных приложений**
        
        1. **Нативные приложения** **разрабатываются специально для определенной операционной системы (iOS, Android)** с использованием языков программирования и инструментов, которые рекомендованы производителем платформы (например, Swift для iOS или Java, Kotlin для Android).
        2. **Веб-приложения** — **это мобильные сайты, адаптированные под экраны смартфонов и планшетов**, которые пользователь может использовать через мобильный браузер.
        3. **Гибридные приложения** **сочетают в себе элементы нативных и веб-приложений.** Они разрабатываются с использованием веб-технологий (HTML, CSS и JavaScript) и упаковываются в нативную оболочку, позволяя им работать на разных платформах.
    10. Непосредственно перед тестированием мобильных приложений необходимо изучить **требования и статистически данные** по следующим направлениям:
        
        - Выбор ОС/платформ и версии: важно учитывать популярные ОС и их версии, чтобы покрыть как можно больше потенциальных пользователей.
        - Выбор устройств: следует учитывать разнообразие устройств на рынке, включая разные размеры экранов и характеристики.
        - Выбор форм-фактора: устройства могут быть телефонами, планшетами и другими носимыми устройствами (умные часы), что влияет на процесс тестирования.
    11. **Эмуляторы** - поведение одной системы на другой. Эмулятор копирует как аппаратное, так и программное поведение устройства.
        
        **Симулятор** - это воспроизводит функциональные аспекты системы, но не пытается в точности копировать аппаратное обеспечение.
        
    12. **Тестирование мобильных приложений виды и подходы:**
        
        1. Тестирование на реальных устройствах и эмуляторах
        2. Различные версии ОС и устройств
        3. Сетевые сценарии
        4. Прерывания
        5. Тестирование батареи и производительности
        6. Геолокация и сенсоры и камер
        7. Оффлайн-тестирование
        8. Тестирование безопасности
        9. Кроссплатформенность
    13. Чек лист для тестирование мобильного приложения: [https://habr.com/ru/articles/534190/](https://habr.com/ru/articles/534190/)
        
    
    14. Принципы тестирования:
        
        - **Тестирование показывает наличие дефектов**
            
            Тестирование может показать, что дефекты присутствуют, но оно не может доказать, что дефектов нет. Даже если тесты не находят баги, это не значит, что их нет.
            
        - **Исчерпывающее тестирование невозможно**
            
            Невозможно протестировать все возможные сценарии использования и комбинации данных. Важно сосредоточиться на наиболее критических сценариях и областях, где вероятность появления дефектов наиболее высока.
            
        - **Раннее тестирование**
            
            Тестирование должно начинаться на ранних этапах разработки (например, на этапе проектирования требований), чтобы предотвратить и обнаружить дефекты на более ранних стадиях, что снижает затраты на их исправление.
            
        - **Скопление дефектов**
            
            Дефекты часто сосредотачиваются в небольшом числе модулей или компонентов системы. Поэтому тестирование должно уделять особое внимание наиболее подверженным ошибкам областям.
            
        - **Парадокс пестицида**
            
            Если постоянно запускать одни и те же тесты, то со временем они перестанут находить новые дефекты. Чтобы избежать этого, тесты должны регулярно обновляться и пересматриваться.
            
        - **Тестирование зависит от контекста**
            
            Подход к тестированию может отличаться в зависимости от конкретной системы или проекта. Например, подходы к тестированию банковских приложений и мобильных игр будут различаться.
            
        - **Заблуждение об отсутствии дефектов**
            
            Даже если продукт прошел все тесты и дефекты не были обнаружены, это не означает, что он готов к выпуску. Важно оценить, соответствует ли продукт ожиданиям пользователей и бизнес-требованиям.
            
    15. Типы тестирование. ?
        
        1. Автоматизированное тестирование и Ручное тестирование. Так же к типом могут спросить и вот эти
        
        - Модульное тестирование. Цель - протестировать **отдельные блоки** приложения.
        - Интеграционное тестирование. Цель - проверить **взаимодействие** компонентов приложения.
        - Функциональное тестирование. Цель - проверить работу всех заявленных **функций** приложения.
        - Регрессионное тестирование. Цель - проверить, что **после изменений** уже существующий функционал не сломался.
        - Нагрузочное тестирование. Цель - проверить **максимальную нагрузку**, при которой приложение работает корректно.
        - Тестирование на производительность. Цель - проверить **скорость и корректность работы** приложения при разной нагрузке.
    16. Основные виды тестирование.Назвать 10 видов тестирование?
        
    17. Подходы к интеграционному тестированию?
        
    18. Типы интеграционных тестирований?
        
    19. Расказать про 3 вида тестирование подробней
        
    20. Тестирование по типу приложения какие есть?
        
    21. Какие виды тестирование входят регрессионные тестирование и степень важности?
        
    22. Назвать кратко про динамический и статический тестирование
        
    23. И назвать несколько нефункциональных видов тестов
        
    24. 3 вопроса на выбор? 1. **Что такое интеграционное тестирование и в каких случаях оно используется?** - **Какое место в жизненном цикле разработки занимает регрессионное тестирование и зачем оно необходимо?** - **В чем разница между белым и черным ящиком в контексте тестирования?** - **Какие виды тестирования относятся к нефункциональному тестированию?** - **Что такое дымовое тестирование (Smoke testing) и каковы его основные задачи?** - **Какая цель нагрузочного тестирования и как его результаты могут повлиять на разработку продукта?** - **В чем отличие тестирования производительности от стресс-тестирования?** - **Какое тестирование лучше всего подходит для проверки безопасности системы?** - **Что такое юзабилити тестирование и как оно помогает улучшить продукт?** - **Каковы ключевые различия между альфа и бета тестированием?** - **Что такое приемочное тестирование (Acceptance testing) и когда оно проводится?** - **Каковы основные преимущества и недостатки автоматизированного тестирования по сравнению с ручным?** - **Какие виды тестирования можно автоматизировать, а какие лучше оставить для ручного тестирования?** - **Какова основная цель тестирования совместимости и что оно включает?** - **Что такое тестирование безопасности и какие основные подходы используются в этом виде тестирования?** - **В чем заключается разница между end-to-end тестированием и системным тестированием?** - **Какие типы тестов применяются для проверки мобильных приложений и чем они отличаются от тестирования веб-приложений?**
        
    25. Пирамида тестирование. Рассказать подробно.
        
        1. Пирамида тестирование
            1. Модульное тестирование(юнит)
            2. Интеграционное тестирование
            3. Системное тестирование
            4. E2E(Приемочное тестирование)
        2. Чем выше пирамида тем важность, сложность, скорость, стоимость будет выше.
    26. Основные поля баг-репорт?
        
        1. Название
        2. Описание
        3. Шаги воспроизведения
        4. Ожидаемый результат
        5. Фактический результат
        6. Вложение: Логи, скриншоты, видео, ссылки
    27. Жизненный цикл бага?
        
        1. Новый баг(New bugs) - создание бага
            
        2. Назначен(Assigned) - Назначить ответственность за этот баг
            
        3. Устранен(Fexid) - Баг устранен разработчиком
            
        4. Проверен(verified) - Проверен после устранение бага
            
        5. Закрыт(closed) -Закрыт после всех удачных проверок
            
        6. Повторно открыт - Будет повторно открыть после всех проверок
            
            ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/6eb25ebd-9bd9-463d-b5e2-ce3dfb8cdd5a/image.png)
            
    28. Виды и типы логирование.
        
    29. Чек лист - набор идей. - Быстрое краткое описание идей.
        
        1. Логичность - Цели и пути достижение эти целей
        2. Последовательность и структурированность - Достигается с помощью многоуровневого списка.
        3. Полнота и неизбыточность. - Чек лист должен представлять собой аккуратную сухую выжимку идей, в которых нет дублирования
    30. Тест -кейсы - это подробная, пошаговая описание теста
        
        1. Виды тест-кейсов
            1. Высокоуровневый тест-кейс - это без конкретных входных данных и ожидаемых результатов. Может применяться для интеграционном, системном и так же исследовательском тестирование.
            2. Низкоуровневый тест-кейс - это с конкретными входными даннами ожидаемый и фактический результат. Представляет собой полностью готовый к выполнению тест-кейс.
            3. Спецификация теста - документа, описывающий набор тест-кейсов.
            4. Тест -сценарий - документ. описывающий последовательность действий по выполнению теста.
    31. Содержание тест-кейса
        
        1. Идентификатор тестового кейса и так же может идентификатор набор тестов
        2. Заголовок теста-кейса - название краткое содержание
        3. Описание тест-кейса что будет тестироваться
        4. Предварительные условия
        5. Шаги выполнение
        6. Тестовые данные
        7. Ожидаемый результат
        8. Фактический результат
    32. Техники тест дизайна
        
        1. **Классы эквивалентности**
        2. Граничные значения
        3. Попарного значения
        4. Диаграмма состояний
        5. **Таблица принятия решений**
- Глава 2 основы автотестирование
    
    **Валидация** — это процесс проверки данных на соответствие определенным требованиям или правилам перед их использованием или сохранением.
    
    **Сериализация** — это процесс преобразования данных (объектов, массивов) в формат, который может быть легко передан через сеть, сохранен в файл или базу данных, а затем восстановлен (десериализация) обратно в объект.
    
- Глава 2 сети
    
    1. Основа в сети
        
        - Более подробно
            1. Глобальную(Wan)
                
            2. Локальную(Lan)
                
            3. Так же есть (Nat) - который позволяет из локального переходить в глобальный
                
            4. Чем отличаются IPv4 и IPv6?
                
                Чем отличаются IPv4 и IPv6?
                
                |Характеристика|**IPv4**|**IPv6**|
                |---|---|---|
                |Длина адреса|32 бита|128 бит|
                |Формат записи|Четыре десятичные группы (0–255), разделенные точками (например, `192.168.1.1`)|Восемь групп шестнадцатеричных чисел, разделенных двоеточиями (например, `2001:0db8:85a3::8a2e:0370:7334`)|
                |Количество возможных адресов|~4,3 миллиарда (2³²)|~340 ундециллионов (2¹²⁸)|
                |Наличие NAT (Network Address Translation)|Широко используется из-за нехватки адресов|Не требуется благодаря огромному количеству адресов|
                |Автоконфигурация|Требует DHCP (или ручной настройки)|Поддерживает SLAAC (автонастройка без DHCP)|
                |Безопасность|Встроенной защиты нет|Встроенная поддержка IPsec|
                |Совместимость|Используется в большинстве сетей|Постепенно внедряется, требуется поддержка оборудования и ПО|
                
                **Зачем нужен IPv6?**
                
                IPv4-адреса заканчиваются, и NAT — это временное решение. IPv6 позволяет каждому устройству в мире получить свой уникальный адрес, упрощает маршрутизацию и улучшает безопасность.
                
            5. Что такое подсеть и зачем она нужна? Подсеть (subnet) — это часть более крупной сети, созданная для оптимизации маршрутизации, повышения безопасности и эффективного использования IP-адресов.
                
            6. Что такое шлюз по умолчанию (default gateway)? это сетевое устройство (обычно маршрутизатор), которое используется для передачи данных из одной сети в другую, если конечный адрес не находится в локальной сети.
                
            7. Какие существуют классы IP-адресов? IP-адреса делятся на 5 классов (A, B, C, D, E). A, B и C — это классы коммерческой адресации. D – для многоадресных рассылок, а класс E – для экспериментов.
                
            8. Как работает ARP (Address Resolution Protocol)? ARP (Address Resolution Protocol) — это сетевой протокол, который сопоставляет IP-адреса с MAC-адресами устройств в локальной сети.
                
            9. В чем разница между TCP и UDP?
                
                |Характеристика|**TCP**|**UDP**|
                |---|---|---|
                |**Надежность**|Гарантирует доставку данных|Нет гарантии доставки|
                |**Контроль ошибок**|Проверяет целостность и запрашивает повторную отправку утерянных пакетов|Ошибки не проверяются|
                |**Упорядоченность пакетов**|Данные приходят в правильном порядке|Пакеты могут приходить в разном порядке|
                |**Скорость**|Медленнее из-за контроля доставки|Быстрее, так как нет подтверждений|
                |**Соединение**|Устанавливает соединение (трехстороннее рукопожатие)|Не требует соединения (отправляет пакеты сразу)|
                |**Применение**|Веб-сайты (HTTP, HTTPS), FTP, Email (SMTP, IMAP, POP3)|Видеозвонки, стриминг, VoIP, онлайн-игры|
                
                ### **Когда использовать?**
                
                - **TCP** — когда важна надежность (например, загрузка файлов, просмотр веб-страниц).
                - **UDP** — когда важна скорость и не критична потеря данных (онлайн-игры, потоковое видео).
            10. **Большая инфа по протоколам** **Существует семь уровней протоколов:**
                
                - **Прикладной уровень** - Обеспечивает взаимодействие с пользователем и приложениями.
                    
                    - **HTTP (HyperText Transfer Protocol)** — передача веб-страниц (порт 80).
                    - **HTTPS (HTTP Secure)** — защищенная версия HTTP с TLS/SSL - это сертификаты тройное рука пожатия только более сложной форме(порт 443).
                    - **FTP (File Transfer Protocol)** — передача файлов между устройствами (порты 20, 21).
                    - **SFTP (Secure FTP)** — безопасная передача файлов по SSH (порт 22).
                    - **SMTP (Simple Mail Transfer Protocol)** — отправка электронной почты (порт 25).
                    - **IMAP (Internet Message Access Protocol)** — получение почты с сервера, оставляя копию (порт 143).
                    - **POP3 (Post Office Protocol v3)** — получение почты с удалением с сервера (порт 110).
                    - **DNS (Domain Name System)** — преобразование доменов из IP-адреса (порт 53).
                    - **DHCP (Dynamic Host Configuration Protocol)** — автоматическая выдача IP-адресов (порты 67, 68).
                    - **Telnet** — удаленное управление устройствами без шифрования (порт 23).
                    - **SSH (Secure Shell)** — безопасное удаленное управление (порт 22).
                - **Уровень представления** - который отвечает за обработку, преобразование и шифрование данных перед их передачей на **прикладной уровень**.
                    
                    1. **Форматирование и кодирование данных**
                        - Преобразует данные в формат, который понимает приложение (например, JSON, XML, ASCII, Unicode).
                    2. **Сжатие данных**
                        - Уменьшает размер данных для ускорения передачи (например, ZIP, GZIP).
                    3. **Шифрование и безопасность**
                        - Защищает данные от несанкционированного доступа (например, SSL/TLS).
                    
                    |Протокол|Назначение|
                    |---|---|
                    |**SSL/TLS**|Шифрование данных в интернете (используется в HTTPS, VPN)|
                    |**JPEG, PNG, GIF**|Кодирование изображений|
                    |**MP3, AAC, WAV**|Кодирование аудио|
                    |**MPEG, H.264**|Кодирование видео|
                    |**ASCII, Unicode**|Кодировка символов|
                    |**JSON, XML**|Форматирование данных для веб-приложений|
                    
                - **Сеансовый уровень -** Сеансовый уровень **(Session Layer)** — это **5-й уровень модели OSI**, который отвечает за установку, поддержку и завершение соединений (сеансов) между приложениями.
                    
                    **Основные функции сеансового уровня:**
                    
                    1. **Управление сеансами**
                        
                        - Устанавливает, поддерживает и завершает соединения между клиентом и сервером.
                    2. **Синхронизация данных**
                        
                        - Разбивает поток данных на контрольные точки, чтобы можно было восстановить передачу в случае сбоя.
                    3. **Контроль доступа**
                        
                        - Обеспечивает безопасность соединения (например, аутентификацию пользователей).
                        
                        ### **Примеры протоколов сеансового уровня:**
                        
                        |Протокол|Назначение|
                        |---|---|
                        |**RPC (Remote Procedure Call)**|Удалённый вызов процедур между клиентом и сервером|
                        |**NetBIOS**|Подключение и взаимодействие компьютеров в локальной сети|
                        |**PPTP (Point-to-Point Tunneling Protocol)**|Создание VPN-туннелей|
                        |**SMPP (Short Message Peer-to-Peer Protocol)**|Передача SMS между серверами|
                        |**RTCP (Real-Time Transport Control Protocol)**|Управление потоковым аудио/видео|
                        |**SIP (Session Initiation Protocol)**|Установление голосовых и видеозвонков (например, в VoIP)|
                        
                - **Транспортный уровень** - это **4-й уровень модели OSI**, который отвечает за передачу данных между устройствами и обеспечивает надежность, контроль ошибок и сегментацию.
                    
                    ### **Основные функции транспортного уровня:**
                    
                    1. **Разбиение данных на сегменты**
                        
                        - Данные делятся на пакеты, которые передаются по сети.
                    2. **Контроль целостности**
                        
                        - Проверка ошибок с помощью контрольных сумм и подтверждение получения данных.
                    3. **Обеспечение надежности передачи**
                        
                        - Гарантированная или быстрая доставка в зависимости от протокола.
                    4. **Управление потоком данных**
                        
                        - Контроль скорости передачи, чтобы избежать перегрузки сети.
                    5. **Мультиплексирование**
                        
                        - Одновременно поддерживает несколько соединений (например, загрузка нескольких вкладок в браузере).
                        
                        |**Протокол**|**Характеристики**|**Где используется?**|
                        |---|---|---|
                        |**TCP (Transmission Control Protocol)**|Надежный, с контролем ошибок, гарантирует порядок пакетов|Веб (HTTP/HTTPS), Email (SMTP, IMAP, POP3), FTP|
                        |**UDP (User Datagram Protocol)**|Быстрый, без гарантии доставки, без контроля порядка|Видео- и аудиостриминг (VoIP, Zoom, YouTube), игры|
                        |**SCTP (Stream Control Transmission Protocol)**|Совмещает надежность TCP и скорость UDP, передает несколько потоков данных|IP-телефония, сигнальные протоколы|
                        |**DCCP (Datagram Congestion Control Protocol)**|Контролирует перегрузку сети, но без гарантий доставки|Потоковое видео, IPTV|
                        |**QUIC (Quick UDP Internet Connections)**|Работает поверх UDP, но с надежностью TCP, поддерживает мультиплексирование, встроенное шифрование и быстрый коннект|HTTP/3, Google Chrome, YouTube, Cloudflare, онлайн-игры|
                        
                - **Сетевой уровень -** это **3-й уровень модели OSI**, который отвечает за маршрутизацию, логическую адресацию и доставку пакетов данных между устройствами в разных сетях.
                    
                    ### **Основные функции сетевого уровня:**
                    
                    1. **Маршрутизация**
                        - Определяет оптимальный путь для передачи данных от отправителя к получателю.
                    2. **Логическая адресация**
                        - Использует **IP-адреса** для идентификации устройств в сети.
                    3. **Фрагментация и сборка пакетов**
                        - Делит большие сообщения на более мелкие пакеты и собирает их на принимающей стороне.
                    4. **Обнаружение и исправление ошибок**
                        - Проверяет целостность пакетов (но не гарантирует их исправление, этим занимается транспортный уровень).
                    
                    ### **Примеры протоколов сетевого уровня:**
                    
                    |**Протокол**|**Характеристики**|**Где используется?**|
                    |---|---|---|
                    |**IP (Internet Protocol)**|Основной протокол сетевого уровня, маршрутизирует пакеты данных|Интернет, локальные сети|
                    |**IPv4**|32-битные IP-адреса, широко используется, но постепенно заменяется IPv6|Интернет, корпоративные сети|
                    |**IPv6**|128-битные адреса, больше возможностей и безопасности|Будущее Интернета, мобильные сети|
                    |**ICMP (Internet Control Message Protocol)**|Обмен служебными сообщениями (ping, ошибки сети)|Диагностика сети (ping, traceroute)|
                    |**ARP (Address Resolution Protocol)**|Преобразует IP-адрес в MAC-адрес|Локальные сети (Ethernet, Wi-Fi)|
                    |**RARP (Reverse Address Resolution Protocol)**|Определяет IP-адрес по MAC-адресу|Старые сетевые устройства|
                    |**OSPF (Open Shortest Path First)**|Протокол динамической маршрутизации, ищет кратчайший путь|Маршрутизация в больших сетях|
                    |**BGP (Border Gateway Protocol)**|Управляет маршрутизацией между автономными системами (ISP)|Глобальный интернет, провайдеры|
                    |**NAT (Network Address Translation)**|Позволяет нескольким устройствам использовать один внешний IP-адрес|Домашние роутеры, корпоративные сети|
                    
                - **Канальный уровень -** это **2-й уровень модели OSI**, который отвечает за надежную передачу данных между устройствами в пределах одной сети. Он обеспечивает контроль доступа к физической среде и формирование фреймов для передачи.
                    
                    ### **Основные функции канального уровня:**
                    
                    1. **Формирование фреймов**
                        - Делит данные на фреймы, добавляя заголовки с адресами и контрольной суммой.
                    2. **Контроль доступа к среде**
                        - Управляет доступом устройств к общей передающей среде (например, Ethernet, Wi-Fi).
                    3. **Обнаружение и коррекция ошибок**
                        - Проверяет целостность передаваемых данных, используя контрольные суммы и другие механизмы.
                    4. **Управление потоком данных**
                        - Контролирует скорость передачи данных, чтобы предотвратить перегрузки.
                    5. **Адресация**
                        - Использует **MAC-адреса** для идентификации устройств в локальной сети.
                    
                    **Примеры протоколов канального уровня:**
                    
                    |**Протокол**|**Характеристики**|**Где используется?**|
                    |---|---|---|
                    |**Ethernet**|Наиболее распространенный стандарт передачи данных по проводным сетям, использует MAC-адреса|Локальные сети (LAN), проводные соединения|
                    |**Wi-Fi (IEEE 802.11)**|Стандарт для беспроводных сетей, использует аналогичные Ethernet принципы, но для радиочастот|Беспроводные сети (Wi-Fi), мобильные устройства|
                    |**PPP (Point-to-Point Protocol)**|Протокол канала передачи данных, используется для точка-точка соединений|VPN, модемы, DSL-соединения|
                    |**HDLC (High-Level Data Link Control)**|Стандарт для надежной передачи данных по каналам связи|ISDN, линия связи между маршрутизаторами|
                    |**Frame Relay**|Протокол для передачи данных с использованием виртуальных каналов|Мобильные сети, выделенные линии связи|
                    |**ATM (Asynchronous Transfer Mode)**|Используется для передачи данных в режиме постоянного потока с высокой скоростью|Высокоскоростные сети, мультимедийные приложения|
                    |**ARQ (Automatic Repeat Request)**|Используется для повторной передачи пакетов в случае ошибок|Беспроводные и проводные сети, беспроводные устройства|
                    |**FDDI (Fiber Distributed Data Interface)**|Стандарт для высокоскоростных сетей на основе оптоволокна|Высокоскоростные оптоволоконные сети|
                    
                - **Физический уровень (Physical Layer)** — это **1-й уровень модели OSI**, который отвечает за физическую передачу данных по каналу связи. Он управляет преобразованием битов в электрические сигналы, световые импульсы или радиоволны, в зависимости от типа канала передачи. Bluetooth, DSL (Digital Subscriber Line), Fiber Optic (Оптоволоконная передача), RS-232, USB (Universal Serial Bus), ISDN (Integrated Services Digital Network)
                    
                - Пример что произходит когда открываеться страница
                    
                    ### **1. Ввод URL в браузере**
                    
                    ### **Что происходит:**
                    
                    Когда вы вводите URL в адресную строку браузера (например, [](https://www.example.com/)[https://www.example.com](https://www.example.com)), браузер начинает процесс запроса этой веб-страницы.
                    
                    - **Прикладной уровень (Application Layer)**:Браузер формирует **HTTP(S) запрос**. Так как протокол HTTPS используется, он также инициирует создание защищённого соединения через **TLS/SSL**. На этом этапе браузер собирает все необходимые данные для подключения к серверу (например, адрес веб-сайта).
                    
                    ---
                    
                    ### **2. Проверка DNS**
                    
                    ### **Что происходит:**
                    
                    Прежде чем браузер отправит запрос на сервер, он должен преобразовать доменное имя ([www.example.com](http://www.example.com/)) в IP-адрес, так как сети и маршрутизаторы используют IP-адреса для передачи данных.
                    
                    - **Прикладной уровень (Application Layer)**:
                        
                        Процесс преобразования доменного имени в IP-адрес выполняется с использованием **DNS (Domain Name System)**. Браузер отправляет запрос на DNS-сервер для получения IP-адреса.
                        
                        - Если в кеше браузера или операционной системы есть сохранённый IP-адрес для этого домена, браузер использует его.
                        - Если нет, браузер отправляет запрос к DNS-серверу для получения IP-адреса.
                    
                    ---
                    
                    ### **3. Установка TCP-соединения (Тройное рукопожатие TCP)**
                    
                    ### **Что происходит:**
                    
                    Браузер теперь знает IP-адрес сервера (например, 93.184.216.34 для [example.com](http://example.com)) и может начать установку соединения с сервером.
                    
                    - **Транспортный уровень (Transport Layer)**:
                        
                        В случае использования TCP (что характерно для HTTPS), устанавливается соединение между клиентом и сервером с использованием тройного рукопожатия.
                        
                        1. **SYN**: Клиент отправляет пакет с флагом **SYN**, который сигнализирует серверу о намерении установить соединение.
                        2. **SYN-ACK**: Сервер отвечает пакетом с флагом **SYN-ACK**, подтверждая готовность установить соединение.
                        3. **ACK**: Клиент подтверждает соединение, отправляя пакет с флагом **ACK**.
                        
                        После этих шагов устанавливается соединение, и клиент может начать передавать данные.
                        
                    
                    ---
                    
                    ### **4. Шифрование данных (если используется HTTPS)**
                    
                    ### **Что происходит:**
                    
                    Если сайт использует HTTPS, то на этом этапе происходит установление защищённого соединения через **TLS** (Transport Layer Security).
                    
                    - **Представление (Presentation Layer)**:На этом уровне происходит создание защищённого канала для передачи данных между клиентом и сервером.
                        - **TLS Handshake**: Браузер и сервер обменяются сертификатами и согласуют параметры шифрования. Сервер передает свой публичный ключ, а клиент генерирует общий секретный ключ.
                        - Данные, которые передаются между клиентом и сервером, будут зашифрованы с использованием согласованного ключа.
                    
                    ---
                    
                    ### **5. Отправка HTTP-запроса на сервер**
                    
                    ### **Что происходит:**
                    
                    Теперь, когда соединение установлено и защищено (если используется HTTPS), браузер отправляет HTTP-запрос к серверу для получения веб-страницы.
                    
                    - **Прикладной уровень (Application Layer)**:Формируется **HTTP-запрос** с необходимой информацией. Например, для запроса главной страницы веб-сайта это может быть запрос вида:Запрос включает:
                        
                        ```
                        vbnet
                        КопироватьРедактировать
                        GET / HTTP/1.1
                        Host: www.example.com
                        User-Agent: Mozilla/5.0
                        Accept: text/html
                        
                        ```
                        
                        - Метод HTTP (GET), который указывает серверу, что нужно вернуть ресурс.
                        - Адрес ресурса (в данном случае корневую страницу "/").
                        - Информацию о том, что клиент (браузер) поддерживает отображение HTML.
                    
                    ---
                    
                    ### **6. Маршрутизация запроса через сеть**
                    
                    ### **Что происходит:**
                    
                    Запрос от клиента отправляется по сети к серверу через маршрутизаторы, которые работают на **сетевом уровне**.
                    
                    - **Сетевой уровень (Network Layer)**:Запрос инкапсулируется в **IP-пакет**, который содержит:IP-пакет маршрутизируется через несколько сетевых устройств (маршрутизаторов), которые определяют лучший путь для передачи пакета от клиента к серверу.
                        - **IP-адрес клиента** (IP-адрес вашего устройства).
                        - **IP-адрес сервера** (например, 93.184.216.34).
                    
                    ---
                    
                    ### **7. Канальный уровень (Data Link Layer)**
                    
                    ### **Что происходит:**
                    
                    Когда IP-пакет достигает локальной сети или непосредственно сервера, данные инкапсулируются в **фрейм** канала передачи данных.
                    
                    - **Канальный уровень (Data Link Layer)**:
                        
                        Фрейм добавляет информацию о **MAC-адресах** (физические адреса устройств), что необходимо для доставки данных на уровне локальной сети (например, Ethernet или Wi-Fi).
                        
                        Данные передаются через физическое соединение, будь то кабель (Ethernet) или беспроводное соединение (Wi-Fi).
                        
                    
                    ---
                    
                    ### **8. Физический уровень (Physical Layer)**
                    
                    ### **Что происходит:**
                    
                    После инкапсуляции данных в фреймы канала, данные передаются через физический носитель.
                    
                    - **Физический уровень (Physical Layer)**:Биты данных (представляющие фрейм) преобразуются в физические сигналы, которые передаются по сети:
                        - Если это Ethernet, то данные передаются через электрические импульсы по проводам.
                        - Если это Wi-Fi, данные передаются через радиоволны.
                    
                    ---
                    
                    ### **9. Сервер обрабатывает запрос и отправляет ответ**
                    
                    ### **Что происходит:**
                    
                    Теперь запрос достиг сервера. Сервер обрабатывает запрос и генерирует ответ.
                    
                    - **Прикладной уровень (Application Layer)**:Сервер принимает запрос, обрабатывает его и формирует ответ в виде HTML-страницы (или других ресурсов). Этот ответ может включать HTML, CSS, JavaScript, изображения и другие данные.
                    
                    ---
                    
                    ### **10. Ответ проходит по всем уровням и возвращается в браузер**
                    
                    ### **Что происходит:**
                    
                    Ответ сервера передается обратно через все уровни OSI (физический, канальный, сетевой, транспортный, сеансовый, представление и прикладной), но теперь в обратном порядке.
                    
                    - **Транспортный уровень (Transport Layer)**:Ответ инкапсулируется в TCP-сегменты, и данные отправляются обратно через установившееся соединение.
                    - **Сетевой уровень (Network Layer)**:Ответ инкапсулируется в IP-пакеты.
                    - **Канальный уровень (Data Link Layer)** и **Физический уровень (Physical Layer)**:Данные передаются по сети обратно к вашему устройству.
                    
                    ---
                    
                    ### **11. Декодирование и отображение страницы в браузере**
                    
                    ### **Что происходит:**
                    
                    Когда данные возвращаются в браузер, они проходят через каждый уровень в обратном порядке, пока не достигнут прикладного уровня, где браузер обрабатывает HTML-контент и отображает страницу пользователю.
                    
                    - **Прикладной уровень (Application Layer)**:Браузер получает ответ от сервера (например, HTML-контент страницы) и обрабатывает его. Он загружает CSS и JavaScript, чтобы отобразить страницу.
                    - **Представление (Presentation Layer)**:Если данные были зашифрованы, они теперь расшифровываются.
                    - **Сеансовый уровень (Session Layer)**:Устанавливается сессия для общения с сервером, и, если нужно, используются куки.
                    
                    ### **Итог:**
                    
                    После того как браузер обработает все данные, вы увидите веб-страницу в своем браузере.
                    
            11. **В чем разница между коммутатором (switch) и маршрутизатором (router)?**
                
                - **Коммутатор (Switch):**
                    - Работает на **канальном уровне** модели OSI (Data Link Layer).
                    - Его основная задача — **управление потоком данных** между устройствами в одной локальной сети (LAN).
                    - Коммутатор анализирует **MAC-адреса** (уникальные идентификаторы устройств в сети) и направляет данные между устройствами внутри одной сети.
                    - Он использует таблицы MAC-адресов для того, чтобы знать, куда передавать данные.
                    - Коммутатор **не управляет** трафиком между различными сетями, только внутри своей сети.
                - **Маршрутизатор (Router):**
                    - Работает на **сетевом уровне** модели OSI (Network Layer).
                    - Его основная задача — **перенаправление пакетов между различными сетями**.
                    - Маршрутизатор использует **IP-адреса** для того, чтобы определить, в какую сеть и к какому устройству направить данные.
                    - Он анализирует таблицы маршрутов и выбирает оптимальный путь для передачи данных между различными сетями (например, между вашей локальной сетью и интернетом).
                    - Маршрутизатор может подключать различные локальные сети (например, домашнюю и офисную) или сеть к глобальной (интернет).
            12. **Как работает VLAN?** это виртуальная локальная сеть, которая позволяет разделить физическую сеть на несколько логических подсетей, что дает возможность изолировать трафик между различными группами устройств, находящихся на одном физическом сегменте сети.
                
            13. **Что такое MAC-адрес и для чего он используется? MAC-адрес** (Media Access Control address) — это уникальный идентификатор, назначаемый каждому сетевому устройству на физическом уровне. Он используется для определения и адресации устройств в сети. MAC-адрес представляет собой 48-битное значение, обычно записываемое в виде шести пар шестнадцатеричных чисел, разделённых двоеточиями или дефисами, например: `00:14:22:01:23:45`.
                
    2. **Клиент-серверная архитектура** — это модель взаимодействия между двумя сторонами: **клиентом** (программой, инициирующей запрос) и **сервером** (программой, обрабатывающей запрос и отправляющей ответ)
        
        - **Клиент** — это устройство или приложение, которое отправляет запросы на сервер для получения данных или выполнения операций. Примеры: веб-браузеры, мобильные приложения, ПК.
        - **Сервер** — это устройство или приложение, которое обрабатывает запросы клиентов, выполняет операции или предоставляет необходимые данные. Серверы могут быть файловыми, веб-серверами, базами данных и т.д.
        - **Протоколы связи** — клиент и сервер обмениваются данными по определенным правилам (протоколам), таким как HTTP, FTP, TCP/IP.
        - **Масштабируемость** — серверы могут обслуживать множество клиентов одновременно, используя разные ресурсы и средства для обработки большого количества запросов.
        - **Примеры**: веб-сайты (клиент — браузер, сервер — веб-сервер), электронная почта (клиент — почтовая программа, сервер — почтовый сервер), базы данных (клиент — программа, сервер — база данных).
    3. Основные виды архитектуры клиент-сервер:
        
        1. **Одноуровневая архитектура (1-Tier) - это тип архитектуры программного обеспечения, в которой все компоненты системы (данные, логика и интерфейс) находятся в одном и том же приложении или среде. например базы данных**
        2. **Двухуровневая архитектура (2-Tier) -** Эта модель разделяет приложение на два независимых компонента
        3. **Трехуровневая архитектура (3-Tier) -** это архитектурная модель, которая разделяет приложение на три независимых уровня: **пользовательский интерфейс (представление)**, **бизнес-логика** и **уровень данных**
        4. **Многоуровневая архитектура (N-Tier) - это гибкая и модульная модель для построения сложных систем, которая позволяет разделить приложение на несколько уровней.**
    4. **Характеристики архитектуры «клиент-сервер» !!!**
        
        1. Асимметричность протоколов. - это характеристика сетевых протоколов, при которой потоки данных и операции между двумя сторонами (клиентом и сервером) распределяются неравномерно
        2. Инкапсуляция услуг.
        3. Модульный дизайн
        4. Масштабируемость
    5. **Микросервисная архитектура** — это способ разработки программного обеспечения, где приложения состоят из небольших, независимых компонентов, называемых микросервисами.
        
    6. Монолитная архитектура – это **организации приложений, в котором все компоненты продукта находятся внутри одной монолитной кодовой базы**.
        
    7. **Характеристики микросервиса**
        
        1. **Мультикомпонентные - это программа разбита на несколько служб т**аким образом каждую из этих служб можно развертывать, настраивать, а затем повторно развертывать независимо друг от друга без ущерба для целостности приложения.
        2. Созданы для бизнеса: Стиль микросервисов обычно организован вокруг бизнес-возможностей и приоритетов.
        3. **Простая маршрутизация**: Микросервисы действуют примерно так же, как классическая система UNIX: они получают запросы, обрабатывают их и генерируют соответствующий ответ.
        4. **Децентрализованные: Поскольку микросервисы включают множество технологий и платформ, старые методы централизованного управления не являются оптимальными. Сообщество микросервисов предпочитает децентрализованное управление, потому что его разработчики стремятся создавать полезные инструменты, которые затем могут использоваться другими для решения тех же проблем. Как и децентрализованное управление, микросервисная архитектура также способствует децентрализованному управлению данными. Монолитные системы используют одну логическую базу данных для разных приложений. В микросервисном приложении каждая служба обычно управляет своей уникальной базой данных;**
        5. **Отказоустойчивые**: Как всесторонне развитый ребенок, микросервисы созданы, чтобы справляться с ошибками.
        6. **Эволюционные**: Архитектура микросервисов представляет собой эволюционный дизайн и, опять же, идеально подходит для эволюционирующих систем, в которых вы не можете полностью предвидеть типы устройств, которые однажды могут получить доступ к вашему приложению. , можно постепенно преобразовать в микросервисы, взаимодействующие с более старой монолитной архитектурой через API.
    8. HTTP - протокол передачи гипертекста
        
    9. Основные методы http запросов
        
        1. **OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. Так же для тестирование.**
        2. GET - Получить ресурс по параметрам. Запрос считается идемпотентным.
        3. **HEAD**: Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения. Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше - копия ресурса помечается как устаревшая;
        4. **POST**: Применяется для передачи пользовательских данных заданному ресурсу
        5. PUT:В основном служит для обновления данных.
        6. **PATCH**: Аналогично PUT, но применяется только к фрагменту ресурс. Проще говоря обновляет выбранную часть данных.
        7. **DELETE**: Удаляет указанный ресурс;
        8. **TRACE**: Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе;
        9. **CONNECT**: Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищенного SSL-соединения через нешифрованный прокси.
    10. Идемпотентность запроса — это **состояние системы изменится только один раз** при многократном вызове GET, PUT, DELETE
        
        1. В сравнении с PUT и PATH
        2. Метод **PUT** считается идемпотентным, потому что повторный запрос с одинаковыми данными всегда приводит к одному и тому же результату — ресурс будет либо создан, либо обновлён до заданного состояния, и последующие вызовы не изменят его больше, чем при первом вызове.
        3. **PATCH** используется для частичного обновления ресурса. Это означает, что каждый раз, когда вы отправляете запрос, он может изменять только определённую часть ресурса, и результат может отличаться в зависимости от текущего состояния ресурса.
        4. Различие между PUT и PATCH:
        
        - **PUT** заменяет весь ресурс новыми данными, то есть после нескольких вызовов ресурс всегда будет в одном и том же состоянии.
        - **PATCH** изменяет только указанные части ресурса, и повторные вызовы могут применяться к уже изменённому состоянию ресурса, что приводит к различным результатам.
    11. Какие есть классы кодом состояния:
        
        1. 100 - Информационный
        2. 200 - Информация об успешным выполнением
        3. 300 - Перенаправление
        4. 400 - Ошибка клиента
        5. 500 - Ошибка сервера
    12. Версия http
        
        1. Существует 3 версии http. По дефолту идёт 1.1. Версия 1 и 2 использует протокол TC.
        
        ||1.1|2|3|
        |---|---|---|---|
        |Transport|TCP|TCP|QUIC|
        |Format|Text|Binary|Binary|
        |Parallel requests|Последовательно один за одним|Есть возможность параллельный запрос по одному конекжнену. Многопоточный|Параллельный .|
        |Requests priority||||
        |Приоритет запросов|нет|||
        |Нет последовательности выполнении запросов|да|||
        |Есть последовательности выполнении запросов|да|||
        |Есть последовательности выполнении запросов||||
        |Headers compression|Сжатия хедеров не доступно|Сжатия хедеров доступно|Сжатия хедеров доступно|
        |Server push|No (Отправление от сервера не доступна)|Yes (Отправление от сервера доступна)|Yes (Отправление от сервера доступна)|
        |||||
        
    13. Протоколы **TCP** и QUIC:
        
        1. **TCP (Transmission Control Protocol)**
        
        **TCP (Transmission Control Protocol)** — это один из основных протоколов интернета, **обеспечивающий надежную передачу данных между компьютерами**. Его ключевая особенность — гарантия того, что данные переданы корректно и в правильном порядке.
        
        ### Основные особенности TCP:
        
        2. **Надежность**:
            - TCP гарантирует доставку данных без ошибок. **Если пакет теряется** или повреждается в процессе передачи, протокол **автоматически запрашивает его повторную отправку**.
        3. **Управление потоком**:
            - **TCP регулирует скорость передачи данных**, чтобы не перегружать сеть или приемное устройство. Это позволяет адаптироваться к состоянию сети и снижать нагрузку при пиковых запросах.
        4. **Порядок доставки**:
            - TCP **нумерует передаваемые пакеты,** что гарантирует правильный порядок их получения, даже если пакеты приходят в неправильной последовательности.
        5. **Трехстороннее рукопожатие**:
            
            - Для установления соединения между клиентом и сервером TCP использует процесс, называемый **"трехсторонним рукопожатием"**. **Это последовательность из трех шагов, где оба устройства обмениваются подтверждениями о готовности к передаче данных.**
            
            1. **SYN** (Синхронизация) — **клиент** инициирует соединение, **отправляя серверу** сегмент с флагом **SYN** (Synchronize), который содержит начальный номер последовательности (sequence number). **Это запрос на установление соединения.**
                
                **Пример:** Клиент → Сервер: [SYN, seq=x]
                
            2. **SYN-ACK** (Синхронизация и подтверждение) — **сервер, получив запрос,** отправляет клиенту сегмент с флагами **SYN** и **ACK** (Acknowledgment). В этом сегменте сервер также передает свой начальный номер последовательности, а также **подтверждает получение** сегмента клиента (ACK = x+1).
                
                **Пример:** Сервер → Клиент: [SYN, ACK, seq=y, ack=x+1]
                
            3. **ACK** (Подтверждение) — **клиент, получив ответ сервера, отправляет ему** сегмент с флагом **ACK**, подтверждая получение сегмента от сервера (ACK = y+1). После **этого соединение считается установленным, и обе стороны могут начинать передавать данные.**
                
        6. **Применение**:
            - TCP широко используется в приложениях, где требуется надежность передачи данных, например, в веб-браузерах (HTTP/HTTPS), электронной почте (SMTP, IMAP), загрузке файлов (FTP) и других.
        
        ### Преимущества TCP:
        
        - Надежная передача данных.
        - Контроль за перегрузками сети.
        - Обеспечение правильного порядка доставки данных.
        
        **IP (Internet Protocol)** — это основной протокол, используемый для передачи данных в сети Интернет и других сетях. Он определяет, как данные, такие как сообщения или файлы, **разбиваются на небольшие пакеты, передаются от отправителя к получателю и как эти пакеты доставляются по сети.** IP работает на сетевом уровне модели OSI и играет ключевую роль в маршрутизации данных между устройствами.
        
        ### Недостатки TCP:
        
        - Более высокая задержка из-за всех механизмов проверки и подтверждения.
        - Более сложная структура пакетов по сравнению с другими протоколами, например, UDP (User Datagram Protocol), который не гарантирует надежности.
        
        **TCP — это основа для большинства интернет-приложений, требующих гарантии точности и последовательности передачи данных**
        
        QUIC (Quick UDP Internet Connections) — **это транспортный протокол, разработанный** Google для улучшения производительности веб-соединений. Он использует UDP вместо традиционного TCP, **чтобы уменьшить задержки и ускорить установку соединения.** Вот несколько ключевых особенностей QUIC:
        
        1. **Меньше задержек**: QUIC стремится минимизировать время, необходимое для установления соединения, сокращая количество раунд-трипов (RTT) для настройки соединения.
        2. **Интегрированное шифрование**: QUIC включает шифрование в свой протокол, что делает соединение более безопасным и защищенным от прослушивания.
        3. **Многопоточность**: QUIC поддерживает мультиплексирование потоков данных без блокировки (head-of-line blocking), что позволяет нескольким запросам передаваться одновременно и эффективно.
        4. **Улучшенная обработка потерь**: Благодаря использованию UDP, QUIC может лучше справляться с потерей пакетов и задержками, чем традиционный TCP.
        5. **Совместимость с HTTP/3**: QUIC используется в HTTP/3, что делает его важным для современных веб-технологий.
        
        QUIC активно используется в крупных интернет-компаниях и поддерживается большинством современных веб-браузеров.
        
    14. https - что означает буква S на конце http
        
        1. Буква s означает защищенный
    15. Идентификация ресурсов в сети URI
        
        1. Cинтаксис
        
        - URI - имя и адрес ресурса в сети, включает в себя URL и URN;
        - URL - адрес ресурса в сети, определяет местонахождение и способ обращения к нему;
        - URN - имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться.
    16. SOAP - **это протокол для обмена структурированными информацией**
        
        1. SOAP (Simple Object Access Protocol) — **это протокол для обмена структурированными сообщениями между приложениями через сеть**. **Он основан на XML** и обычно используется для вызова веб-сервисов. SOAP работает поверх различных транспортных протоколов (например, HTTP, SMTP) и поддерживает **сложные механизмы безопасности и надежности передачи данных.**
        
        ### Основные особенности SOAP:
        
        - **Формат XML**: Все сообщения структурированы в формате XML.
        - **Транспортная независимость**: Может работать поверх различных протоколов (HTTP, SMTP и др.).
        - **Строгая спецификация**: Чётко определённые стандарты для обмена данными.
        - _Поддержка WS- стандартов_: Включает механизмы безопасности, маршрутизации, обработки ошибок и транзакций.
        
        SOAP часто используется в корпоративных приложениях, требующих сложных взаимодействий и высокого уровня безопасности.
        
    17. **REST - Архитектурный стиль запросов**
        
        1. Есть альтернатива RPC
        2. Обязательные требование. производительность, масштабируемость, простота, надежность, переносимость.
        3. Обязательными условиями-ограничениями являются:
            1. **Модель клиент-сервер**
            2. **Отсутствие состояния**
            3. **Кэширование**
            4. **Единообразие интерфейса**
            5. **Слои**
            6. **Код по требованию** (необязательное ограничение).
    18. **Сокеты** - абстрактный объект**,** представляющий **конечную точку соединения.** Проще говоря, **эта** **технология** **позволяет** **установить связь между клиентом и сервером с минимальными затратами, позволяя создавать приложения, использующие все преимущества живого общения.**
        
        1. **WebSocket - протокол связи поверх TCP-соединения**, **предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени. Пример**: ajax - возможность получить или обновить данные без перезагрузки
    19. **Веб-хуки** (webhooks) — **это механизм, с помощью которого одно приложение может уведомлять другое приложение о каких-либо событиях** или изменениях данных в реальном времени.
        
    20. **Хранилище на стороне клиента**(Персонализация настроек, сохранение предыдущей настройки сайта)
        
        1. Cookie - для хранение данных о клиенте
        2. Типы cookie
            1. **Сессионные cookie**(временные куки) - существуют только во временной памяти, пока пользователь находиться на странице. Обычно не имеют истечения срока действия, и поэтому браузеры понимают их как сессионные.
            2. **Постоянные cookie** - устанавливается временем. Еще называют следящие куки.
            3. **Сторонние cookie** - Например рекламные куки
            4. **Супер-cookie** - Это cookie-файл с источником домена верхнего уровня
            5. **Зомби-cookie - Трудно удаляемы куки**
        3. Тестирование файлов:
            1. необходимо проверить статус файла cookie, срок действия файла cookie, доступность файла cookie, ограничения безопасности и т. д.
    21. Кэш — это временное хранилище данных, предназначенное для ускорения повторного доступа к часто запрашиваемой информации
        
        1. Категории кэшей
            1. Приватный предназначен для отдельного пользователя.
            2. Общий прокси-кэш: это кэш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи.
        2. Виды кэширования:
            1. В основном (Браузерные, **Сервисные, Процессоры**)
            2. **Браузерное кэширование или клиентское кэширование: Работа такого кэширования основана на том, что при повторном посещении, браузеру отдаётся заголовок 304 Not Modified, а сама страница или картинка загружаются из локального пользовательского кэша**
            3. **Кэширование файлов и картинок - Наиболее эффективным считается кэширование на 2 недели. Однако в данном случае есть важный нюанс: если изображение на сайте меняется, то браузер узнает об этом не сразу, а только если выждать expiry или сбросить кэш в самом браузере. Это не очень эффективно, если файл постоянно изменяется и необходимо постоянно отдавать его актуальную версию.**
            4. **Кэширование https**
            5. **Кэширование центра сертификации - кэширование сертификатов**
            6. **Кэширование страниц - кэшируется страница**
            7. Серверное кэширование - кэшируется на стороне сервера. В основном происходит связь один ко многим где многие это клиента
            8. Кэширование страницы целиком - главное преимущество в том что страница открывается очень быстро. Недостаток в том что страница становиться больше статическая. Это идеально для гостевых пользователей
            9. **Кэширование отдельных блоков страницы**
            10. Кэширование mysql на основе query cache
            11. **Кэширование mysql результатов работы, агрегирующие таблицы**
            12. **Кэширование прокси-серверы**
            13. Шлюзы - какая либо группа
            14. Прямые прокси-серверы
            15. Веб-ускорители - делает заранее не которые операции уменьшает качество изображения и так далее
            16. Обратные прокси-серверы - используется для балансировки нагрузки между несколькими внутренними серверами
            17. Пограничное кэширование -Обратные прокси-серверы расположены близко к серверам
        3. **Принципы работы кэша:**
            
            1. **Чтение данных из кэша**: Когда система запрашивает данные, сначала проверяется, есть ли они в кэше. Если данные найдены (это называется **кэш-хитом**), они возвращаются из кэша, что значительно быстрее. Если данные не найдены (это **кэш-промах**), происходит обращение к основному источнику данных, после чего результат сохраняется в кэше для будущих запросов.
            2. **Срок хранения и обновление кэша**:
            
            - Данные в кэше хранятся ограниченное время, после чего они могут быть обновлены или удалены. Время хранения данных определяется политиками, такими как **TTL (Time to Live)**.
            - Если данные изменяются в основном источнике, кэш должен быть обновлен, чтобы предотвратить использование устаревшей информации.
    22. **Аутентификация и авторизация (Authentication and authorization)**
        
        **Идентификация** - ставиться какой ни будь идентификатор
        
        **Аутентификация** - процедура проверки подлинности, например проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
        
        **Авторизация** - предоставление определенному лицу или группе лиц прав на выполнение определенных действий.
        
        - Аутентификации на основе сессии
        - Аутентификации на основе токенов
        - Беспарольная аутентификация - в основном почтой
        - **Единая точка входа (Single Sign On, SSO) - авторизация на всех сервисах например GOOGLE**
        - Двухфакторная аутентификация - пример кредитная карта на карте должна быть правильная инфа, и в дополнение к этому вы вводите PIN. тоесть мало только одной информации
    23. Рендеринг это процесс генерации изображения, визуализации графики или формирования данных для их последующего отображения пользователю.
        
        1. Терминология
        
        - **SSR**: рендеринг на стороне сервера - рендеринг клиентского или универсального приложения в HTML на сервере;
        - **CSR**: рендеринг на стороне клиента - рендеринг приложения в браузере, обычно с использованием DOM;
        - Регидратация (**Rehydration**): «загрузка» представлений JavaScript на клиенте так, чтобы они повторно использовали дерево DOM и данные HTML, представленные сервером;
        - Предварительный рендеринг (**Prerendering**): запуск приложения на стороне клиента во время сборки для захвата его исходного состояния в виде статического HTML;
        - **TTFB**: время до первого байта - рассматривается как время между нажатием на ссылку и первым поступающим контентом;
        - **FP**: First Paint - первый раз, когда любой пиксель становится видимым для пользователя;
        - **FCP**: First Contentful Paint - время, когда запрашиваемый контент (тело статьи и т. д.) Становится видимым;
        - **TTI**: Time To Interactive - время, когда страница становится интерактивной (события подключены и т. д.)
        
        1. Виды
            
            1. Серверный рендеринг - генерирует полный html на стороне сервера
            2. Статический рендеринг
            3. Рендеринг на стороне клиента
            4. Объединение серверного рендеринга и csr через регидратацию
            5. Проблема регидратации одно приложение по цене двух
            6. Частичная регидратация
            7. Трисоморфный рендеринг
            8. SEO соображения - зависит от javascript
        2. Как работает рендеринг в браузере
            
            - Из полученного от сервера HTML-документа формируется DOM (Document Object Model).
            - Загружаются и распознаются стили, формируется CSSOM (CSS Object Model).
            - На основе DOM и CSSOM формируется дерево рендеринга, или render tree - набор объектов рендеринга (Webkit использует термин «renderer», или «render object», а Gecko - «frame»). Render tree дублирует структуру DOM, но сюда не попадают невидимые элементы (например - <head>, или элементы со стилем display:none;). Также, каждая строка текста представлена в дереве рендеринга как отдельный renderer. Каждый объект рендеринга содержит соответствующий ему объект DOM (или блок текста), и рассчитанный для этого объекта стиль. Проще говоря, render tree описывает визуальное представление DOM.
            - Для каждого элемента render tree рассчитывается положение на странице - происходит layout. Браузеры используют поточный метод (flow), при котором в большинстве случаев достаточно одного прохода для размещения всех элементов (для таблиц проходов требуется больше).
            - Наконец, происходит отрисовка всего этого добра в браузере - painting.
            
            В процессе взаимодействия пользователя со страницей, а также выполнения скриптов, она меняется, что требует повторного выполнения некоторых из вышеперечисленных операций.
            
            **Adaptive Design (AWD)** - адаптивный дизайн, или динамический показ - проектирование сайта с условиями, которые изменяются в зависимости от устройства, базируясь на нескольких макетах фиксированной ширины.
            
            **Адаптивный и отзывчивый веб-дизайн (Adaptive vs. Responsive) - адаптируется в любом приложение. минус снижается скорость загрузки так как затрачивается на оформление внешнего вида ресурса**
            
            **Уровни логирования**
            
            При любом механизме записи событий их объем все равно будет большим. И работать с таким количеством информации будет достаточно сложно. Поэтому логи структурируют по уровням. Наиболее известными и востребованными являются следующие уровни логирования:
            
            - debug
            - info
            - warning
            - error
            - fatal
            
            **События, связанные с отправкой запроса в адресной строке, происходят в следующем порядке:**
            
            - **Ввод адреса в адресной строке браузера**: Пользователь вводит URL или строку запроса в адресную строку браузера.
            - **DNS-запрос**: Браузер отправляет запрос на DNS-сервер для преобразования доменного имени в IP-адрес.
            - **Установка соединения (TCP/IP)**: После получения IP-адреса браузер устанавливает соединение с сервером с помощью протокола TCP/IP.
            - **Отправка HTTP/HTTPS-запроса**: Браузер отправляет запрос (GET или POST) на сервер с запрашиваемым ресурсом (например, страницей HTML или файлом).
            - **Обработка запроса сервером**: Сервер принимает запрос, обрабатывает его и формирует ответ. В случае динамических страниц может произойти обработка серверного кода (например, PHP, Python, Java).
            - **Отправка ответа браузеру**: Сервер отправляет ответ с данными (например, HTML, JSON, изображения).
            - **Рендеринг страницы в браузере**: Браузер получает ответ и начинает его обрабатывать, загружая и рендеря HTML, CSS, JavaScript, изображения и другие ресурсы.
            - **Отображение страницы пользователю**: После рендеринга браузер отображает страницу пользователю.
- Глава 3 Postman
    
    1. Популярные инструменты:
        1. Коллекции (Collections)
        2. Запросы (Requests)
        3. Среды (Environments)
        4. Переменные (Vфariables)
        5. Тестирование (Tests)
        6. Мониторы (Monitors)
        7. Мок-серверы (Mock Servers)
        8. Автоматизация и скрипты (Pre-request и Post-request Scripts)
        9. Интеграция с CI/CD
        10. Консоль Postman
        11. Работа с веб-сокетами и gRPC
        12. Интеграция с GitHub и другими сервисами
    2. Аналоги:
        1. Insomnia
        2. SoapUI
- Глава 4 kafka
    
    1. Apache Kafka – это распределенная потоковая платформа, позволяющая обрабатывать триллионы событий в день. Kafka гарантирует минимальные задержки, высокую пропускную способность, предоставляет отказоустойчивые конвейеры, работающие по принципу «публикация/подписка» и позволяет обрабатывать потоки событий. Так же работает между микросервисами.
        
    2. Аналоги:
        
        1. RabbitMQ
        2. Apache Pulsar
        3. Amazon Kinesis
        4. Redis Streams
        5. NATS
        6. Google Pub/Sub
        7. ActiveMQ
        8. ZeroMQ
    
    ### 1. **Producer (Производитель)**
    
    3. Каковы основные компоненты Kafka?
        
        Producer — это компонент, который отвечает за отправку сообщений в Kafka. Producers публикуют данные в определённые **топики** (topics). Они могут настраивать параметры, такие как выбор раздела (partition) для отправки сообщения, а также обеспечивать подтверждение доставки сообщений.
        
        - Producers могут отправлять данные с разной степенью гарантии доставки, от "fire-and-forget" до гарантированной доставки с подтверждением.
        
        ### 2. **Consumer (Потребитель)**
        
        Consumer — это компонент, который получает данные из топиков Kafka. Consumers подписываются на один или несколько топиков и обрабатывают сообщения.
        
        - Kafka поддерживает концепцию **групп потребителей** (consumer groups), где сообщения одного раздела доставляются только одному потребителю из группы, что позволяет распределять нагрузку между несколькими потребителями.
        
        ### 3. **Broker (Брокер)**
        
        Брокер — это сервер, который отвечает за хранение сообщений, их получение от производителей и передачу потребителям. Kafka кластер обычно состоит из нескольких брокеров для распределения нагрузки и обеспечения отказоустойчивости.
        
        - Брокеры хранят данные в разделах (partitions) топиков и реплицируют их для обеспечения отказоустойчивости.
        - Каждый брокер в кластере может управлять множеством топиков.
        
        ### 4. **Topic (Топик)**
        
        Топик — это логическое имя канала, по которому организована передача данных. Producers отправляют сообщения в определённые топики, а consumers извлекают их из этих топиков.
        
        - Топики делятся на **разделы** (partitions), что позволяет параллельно обрабатывать данные. Разделы также используются для обеспечения масштабируемости и отказоустойчивости.
        
        ### 5. **Partition (Раздел)**
        
        Каждый топик разбивается на несколько разделов (partitions), которые являются основной единицей параллельной обработки данных в Kafka. Разделы обеспечивают распределение данных между брокерами и позволяют нескольким потребителям обрабатывать сообщения параллельно.
        
        - Разделы имеют **ключевые смещения** (offsets), которые идентифицируют порядок сообщений внутри каждого раздела.
        
        ### 6. **ZooKeeper**
        
        Zookeeper использовался для координации и управления Kafka-кластером (например, для отслеживания состояния брокеров, управлением лидерами разделов). Однако, начиная с версии 2.8.0, Kafka постепенно переходит на использование собственного механизма метаданных без зависимости от ZooKeeper.
        
        ### 7. **Controller (Контроллер)**
        
        Контроллер — это брокер в кластере Kafka, который управляет распределением ролей, таких как назначение лидеров разделов и координация репликаций.
        
        ### 8. **Log (Лог)**
        
        Каждый раздел топика сохраняется как лог-файл на диске. Сообщения в этих лог-файлах упорядочены и имеют уникальные смещения (offsets), что позволяет consumer'ам отслеживать, какие сообщения были обработаны.
        
        ### 9. **Replica (Реплика)**
        
        Kafka использует репликацию для обеспечения отказоустойчивости. Каждый раздел имеет одну или несколько реплик, которые распределены между брокерами. Одна из реплик является **лидером**, а остальные — **фолловерами**. Лидер отвечает за запись и чтение сообщений.
        
        ### 10. **Kafka Connect**
        
        Kafka Connect — это встроенный инструмент для интеграции с различными внешними системами, такими как базы данных или системы хранения данных. Он позволяет легко настроить поток данных между Kafka и этими системами.
        
        ### 11. **Kafka Streams**
        
        Kafka Streams — это библиотека для обработки данных в реальном времени непосредственно внутри Kafka. Она позволяет преобразовывать, фильтровать, агрегировать и объединять данные, предоставляемые Kafka, без необходимости использования внешних систем обработки.
        
    4. **Какова роль Zookeeper в Kafka?**
        
        1. **Zookeeper** используется для координации и управления метаданными в Kafka. Он следит за состоянием брокеров, управляет распределением партиций и отслеживает активные потребители.
    5. Что такое партиционирование
        
        1. **Партиционирование** — это разбиение топика на несколько партиций. Каждая партиция может обрабатываться независимо, что позволяет распределять нагрузку и обеспечивать параллельную обработку данных.
    6. Как Kafka обеспечивает доставку
        
        - **At-most-once**: Сообщения могут быть потеряны, но не дублируются.
        - **At-least-once**: Сообщения могут быть доставлены более одного раза.
        - **Exactly-once**: Сообщения доставляются точно один раз (требует дополнительной конфигурации и поддержки в обработке).
    7. Что такое offset
        
        1. это уникальный идентификатор записи в партиции, который указывает на позицию сообщения. Потребители используют offset для отслеживания, какие сообщения были уже прочитаны, и продолжения с этого места при следующем чтении.
    8. Кафка и микросервисы
        
        ### Основные Принципы
        
        1. **Как Apache Kafka используется для взаимодействия между микросервисами?**
            - Kafka используется как промежуточное звено для асинхронного взаимодействия микросервисов. Каждый микросервис может выступать в роли **продуцента**, публикуя события в топики, и **потребителя**, слушая события других микросервисов через эти топики.
        2. **Какие преимущества дает использование Kafka для связи между микросервисами?**
            - **Асинхронность**: Микросервисы могут взаимодействовать без ожидания мгновенного ответа.
            - **Масштабируемость**: Kafka может обрабатывать большие объемы сообщений и обеспечивать высокую пропускную способность.
            - **Отказоустойчивость**: Kafka хранит сообщения на диске и реплицирует их между брокерами, что обеспечивает высокую доступность и защиту от потери данных.
        
        ### Архитектура и Взаимодействие
        
        3. **Как микросервисы публикуют и потребляют события в Kafka?**
            - Микросервисы публикуют события через **продуцентов** в Kafka, отправляя их в топики. Потребление событий происходит через **потребителей**, которые подписываются на топики и обрабатывают поступающие сообщения.
        4. **Что такое событийно-ориентированная архитектура (Event-Driven Architecture), и как она связана с Kafka?**
            - **Событийно-ориентированная архитектура** (EDA) основывается на идее, что системы взаимодействуют через события. Kafka идеально подходит для реализации такой архитектуры, так как она обеспечивает передачу и обработку событий в реальном времени.
        
        ### Потоковые События и Управление Данными
        
        5. **Как Kafka решает проблемы согласованности данных между микросервисами?**
            - Kafka поддерживает **потоковую репликацию данных** между микросервисами, обеспечивая, что все сервисы получают одинаковые события. Это достигается с помощью механизма **идемпотентности** и гарантии доставки событий, таких как "at least once" или "exactly once".
        6. **Как избежать дублирования сообщений при взаимодействии микросервисов через Kafka?**
            - Для предотвращения дублирования сообщений Kafka использует механизм **идемпотентных продюсеров** и **конечных смещений (offsets)** у потребителей, что позволяет гарантировать, что каждое сообщение будет обработано только один раз.
        
        ### Производительность и Масштабируемость
        
        7. **Каким образом можно масштабировать микросервисы при использовании Kafka?**
            - Масштабирование достигается за счет **партиций топиков**. Микросервисы могут запускать несколько экземпляров, каждый из которых обрабатывает отдельные партиции. Это позволяет распределять нагрузку и обеспечивать параллельную обработку сообщений.
        8. **Как обеспечивается высокая доступность и отказоустойчивость Kafka при взаимодействии микросервисов?**
            - Kafka поддерживает **репликацию партиций**, что позволяет хранить копии данных на нескольких брокерах. В случае сбоя одного из брокеров, другой брокер с репликой берет на себя обработку сообщений.
        
        ### Обработка Событий и Потоков
        
        9. **Что такое Kafka Streams, и как его можно использовать для обработки событий между микросервисами?**
            - **Kafka Streams** — это библиотека для построения приложений, которые обрабатывают данные непосредственно из Kafka в реальном времени. Она позволяет микросервисам выполнять такие операции, как фильтрация, агрегирование и объединение данных между топиками.
        10. **Как Kafka может использоваться для реализации паттерна "Choreography" между микросервисами?**
            - В паттерне **"Хореография"** каждый микросервис реагирует на события, поступающие из Kafka, и может публиковать новые события. Это обеспечивает координацию между микросервисами через события без необходимости централизованного оркестратора.
        
        ### Ошибки и Обработка Исключений
        
        11. **Какие подходы можно использовать для обработки ошибок при коммуникации между микросервисами через Kafka?**
            - При ошибках во время потребления сообщений можно использовать подходы:
                - **Dead-letter queue (DLQ)** — для отправки ошибочных сообщений в отдельный топик для последующей обработки.
                - **Ретрай (Retry)** — повторная попытка обработки сообщения через определенные интервалы времени.
        12. **Как избежать потери данных при сбоях потребителей или продюсеров?**
            - Kafka поддерживает **транзакции**, что позволяет группировать несколько операций публикации или потребления сообщений в одну атомарную транзакцию. Это гарантирует, что все операции выполнятся либо полностью, либо не выполнятся вовсе, что предотвращает потерю данных.
        
        ### Обеспечение Безопасности
        
        13. **Как обеспечивается безопасность при взаимодействии микросервисов через Kafka?**
            - Kafka поддерживает несколько механизмов безопасности:
                - **Аутентификация** с помощью SSL/TLS и SASL для подтверждения подлинности клиентов.
                - **Авторизация** через ACL (Access Control Lists) для управления доступом к топикам и брокерам.
                - **Шифрование данных** в процессе передачи с использованием TLS.
        14. **Какие меры предосторожности следует принять при интеграции микросервисов с Kafka для соблюдения требований к безопасности данных?**
            - Необходимо использовать **шифрование сообщений**, настраивать строгие **политики доступа** через ACL, а также мониторить и аудитировать действия всех клиентов Kafka для выявления подозрительных операций.
    9. Устройство брокеров
        
        1. Топик - это логическое разделение категорий сообщений на группы(Партиции). Например заказы, инвентарь и т.д. Общая логика: Один продюсер может писать один или несколько топиков Один консумер может читать один или несколько топиков В один топик могут писать один или более продюсеров Из одного топика могут читать один или более консумеров.
        2. **Партиции и сегменты Ограничений на количество топиков в кластере Kafka нет, но есть ограничения самого компьютера. Он выполняет операции на процессоре, вводе-выводе, и в итоге упирается в свой предел. Мы не можем увеличивать мощность и производительность машин бесконечно, а потому топик следует делить на части. За счёт этого Kafka может масштабироваться: пользователь может создать топик, разделить его на партиции и разместить каждую из них на отдельном брокере. Формально партиция и есть строго упорядоченный лог сообщений. Каждое сообщение в ней добавлено в конец без возможности изменить его в будущем и как-то повлиять на уже записанные сообщения. При этом сам топик в целом не имеет никакого порядка, но порядок сообщений всегда есть в одной из его партиций.
        
        Каждая партиция на брокере представлена набором сегментов. Сегмент - это файл на диске, который содержит несколько сообщений одной партиции.** Реплики партициий могут быть _**лидерами**_ или _**фолловерами**_. Традиционно консумеры и продюсеры работают с лидерами, а фолловеры только догоняют лидера.
        
        **У партиции можно создать реплики(копия для отката) - могут быть лидерами или фолловерами.
        
        Лидер - это** основная реплика партиции, которая **принимает все записи** от продюсеров и **обрабатывает запросы на чтение** от консумеров. Kafka всегда назначает одну реплику в качестве лидера для каждой партиции. Только лидер отвечает за взаимодействие с внешними компонентами (продюсерами и консумерами). Лидер также отвечает за поддержание консистентности данных между фолловерами, отправляя им записи для синхронизации.
        
        **Фолловеры** — это другие реплики партиции, которые **не принимают напрямую запросы от продюсеров и консумеров**, а только копируют данные с лидера. 3. Консумеры - читают сообщение. У лога может быть несколько консумеров. А еще у консумеров нет привязки по времени к чтению события. При желании они могут читать спустя дни, недели. 4. **Репликация данных - Если одна партиция будет существовать на одном брокере, в случае сбоя часть данных станет недоступной. Такая система будет хрупкой и ненадёжной. Для решения проблемы Kafka представляет механизм репликации партиций между брокерами.**
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/a8ee6ae6-6c48-44bf-aa5c-3b6707942c8b/image.png)
        
        На изображении три репликации. Зеленый это лидер все остальные фолловер которые догоняют. Для репликации обычно требуется доля секунд
        
    10. Продюсеры - отправляет данные сообщение
        
        **Продюсеры самостоятельно партицируют данные в топиках и сами определяют алгоритм партицирования**: он может быть как банальный _**round-robin**_ и _**hash-based**_, так и кастомный.Очередность только для одной партиции. Вся логика реализации партицирования данных реализуется на стороне продюсера
        
        Дизайн продюсера: Пэйлод упаковывается в структуру с указанием топика, партиции и ключа партицирования. Далее сериализуется в подходящий формат. Семантики:
        
        - **At-most-once**: Сообщения могут быть потеряны, но не дублируются.
        - **At-least-once**: Сообщения могут быть доставлены более одного раза.
        - **Exactly-once**: Сообщения доставляются точно один раз (требует дополнительной конфигурации и поддержки в обработке).
        
        **Надёжность доставки: Указать в параметрах acks 0 - Это слабая надежность не дожидаясь никаких подтверждений записи на диск со стороны брокера Указывая настройку 1 будет дожидаться ответа от брокера лидерский партиции**
        
        Указывая -1 - Это самая надежная так будет дожидаться от всех реплик
        
        **Идемпотентные продюсеры - В случаи какого либо сбоя(например сети) программа может повторно отправить запрос в таком случаи нам может помочь идемпотентность включить _enable.idempotence_**. Это избавит от дубликатов ну этого есть своя цена уменьшит производительность
        
    11. **Консумеры -** это компонент, который получает данные из топиков Kafka. Consumers подписываются на один или несколько топиков и обрабатывают сообщения.
        
        1. Партиции в консумер-группах распределяет автоматически _**Group Coordinator**_ при помощи _**Group leader**_ — первого участника в группе. Каждый консумер в группе может читать одну и более партиций разных топиков. Если консумеру не достанется партиции, то он будет бездействовать, что мешает масштабированию.
        2. Основное преимущество консумер-группы перед обычным консумером состоит в хранении оффсета партиций на стороне брокера. Это позволяет консумерам прерывать работу, а после возобновлять её с того же места, где они окончили чтение.
        3. Для проверки живости консумеры отправляют брокеру _**Heartbeat-сообщение**_. Если консумер не успел отправить его, то может покинуть группу сам, либо брокер, который не получил подтверждение, сам удалит консумера из группы, что запустит ребалансировку.
        4. Любая смена композиции партиций в топиках и участников в группе запускает ребалансировку. Это болезненный процесс для консумеров. В этот момент все консумеры остановят чтение и не начнут его до полной синхронизации и стабилизации группы. Есть различные алгоритмы ребалансировки, которые позволяют смягчить процесс, но по умолчанию это _**Stop-The-World**_.
        5. В новом консумере важно правильно выбрать политику оффсета. Иногда читать с начала не нужно и достаточно «перемотать» оффсет в конец, чтобы сразу получать только новые события.
        6. Наконец, два и более консумеров в группе не могут читать из одной и той же партиции. Чтобы не оказаться в ситуации, когда вам некуда масштабироваться при чтении, заранее установите достаточное число партиций.
        
        **Дизайн консумера - консумер периодически вычитывает новую порцию данных, десериализует их и следом обрабатывает.**
        
        **Консумер-группы. Консумер** могут быть объединены в кластер — _**консумер-группы.**_
        
        ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/c35f55f4-c1aa-4c8e-9e82-7ee846b65689/image.png)
        
        **Ребалансировка консумер-групп - композиция группы меняется.**
        
    12. ‣ - пример работы с кафкой с настроеным интерфессом
        
- Глава 5 CI/CD
    
    ci/cd - ci это непрерывная интеграция , cd непрерывная доставка. Непрерывная интеграция - это методология разработки и набор практик, при которых в код вносятся небольшие изменения с частыми коммитами()
    
    CI — обеспечить последовательный и автоматизированный способ сборки, упаковки и тестирования приложений.
    
    такие как сборка (build), тестирование (test) и развертывание (deploy)
    
    CI/CD-конвейеры предназначены для организаций, которым необходимо часто вносить изменения в приложения с надежным процессом поставки. Помимо стандартизации сборки, разработки тестов и автоматизации развертываний мы получаем целостный производственный процесс по развертыванию изменений кода. Внедрение CI/CD позволяет разработчикам сосредоточиться на улучшении приложений и не тратить силы на его развертывание.
    
    Основные этапы CI/CD pipeline
    
    ### **Build Stage (Сборка)**
    
    - **Что делает**: На этом этапе исходный код собирается в артефакт (бинарные файлы, JAR, Docker-образы и т.д.).
    - **Пример**: Компиляция кода, сборка Docker-образов.
    
    ### **Test Stage (Тестирование)**
    
    - **Что делает**: Запуск автоматических тестов для проверки корректности и функциональности кода.
    - **Типы тестов**: Юнит-тесты, интеграционные тесты, тесты безопасности и производительности.
    
    ### **Deploy Stage (Развертывание)**
    
    - **Что делает**: После успешного тестирования приложение развертывается в целевой среде. В зависимости от практик, это может быть dev/staging/production.
    - **Пример**: Развертывание на тестовые сервера или в production среду с использованием Kubernetes, Ansible, или других инструментов.
    - Kubernetes — это мощная система для автоматизации развертывания, масштабирования и управления контейнеризованными приложениями. Если вы начинаете изучать Kubernetes или планируете его использовать, вот основные темы и концепции, которые стоит знать:
- Глава 7 Java **Объекты и классы**
    
    Обращение к объекты имени класса(который храниться в куче) и к переменной которая храниться(стеке) Purchase milk = new Purchase();
    
    Purchase.weight - МОЖНО ОБРАЖАТЬСЯ ТОЛЬКО ЕСЛИ МЕТОД СТАТИЧЕСКИЙ
    
    milk.changeNds(0.25)
    
    static - основное применение
    
    - Генерация через chatgpt применение static
        
        Ключевое слово `static` в Java используется для решения ряда конкретных задач, связанных с эффективностью и логикой работы с классами и объектами. Основные способы применения `static` можно рассмотреть на нескольких примерах.
        
        ### 1. **Общие переменные для всех объектов класса** (статические переменные)
        
        - **Пример использования**: Когда нужно иметь одну переменную, которая будет общей для всех объектов класса, и изменения в одном объекте будут отражаться на всех остальных.
        - **Часто используется для**: Счетчиков объектов, настроек конфигураций и т.д.
        
        **Пример**:
        
        ```java
        java
        Копировать код
        class Counter {
            static int count = 0;
        
            Counter() {
                count++;
            }
        }
        
        public class Main {
            public static void main(String[] args) {
                new Counter(); // count = 1
                new Counter(); // count = 2
                System.out.println(Counter.count); // Output: 2
            }
        }
        
        ```
        
        - В данном примере переменная `count` является общей для всех объектов класса `Counter`, и ее значение увеличивается при создании каждого нового объекта.
        
        ### 2. **Общая функциональность, не зависящая от объекта** (статические методы)
        
        - **Пример использования**: Когда метод не должен зависеть от конкретного экземпляра класса и логика работы может быть выполнена на уровне класса.
        - **Часто используется для**: Вспомогательных методов (утилитарные классы), фабричных методов.
        
        **Пример**:
        
        ```java
        java
        Копировать код
        class MathUtil {
            static int add(int a, int b) {
                return a + b;
            }
        }
        
        public class Main {
            public static void main(String[] args) {
                int sum = MathUtil.add(5, 10); // Вызов статического метода
                System.out.println(sum); // Output: 15
            }
        }
        
        ```
        
        - Статический метод `add` выполняет сложение без необходимости создания объекта класса `MathUtil`. Это удобно для таких вспомогательных операций.
        
        ### 3. **Контекст класса без создания объекта** (статические блоки инициализации)
        
        - **Пример использования**: Когда нужно инициализировать статические переменные или выполнить одноразовую настройку при загрузке класса в память.
        - **Часто используется для**: Настройки конфигурации класса или предустановки данных.
        
        **Пример**:
        
        ```java
        java
        Копировать код
        class Database {
            static String connectionString;
        
            static {
                connectionString = "jdbc:mysql://localhost:3306/mydb";
                System.out.println("Подключение к базе данных установлено.");
            }
        }
        
        public class Main {
            public static void main(String[] args) {
                System.out.println(Database.connectionString);
            }
        }
        
        ```
        
        - Статический блок инициализации выполняется только один раз при загрузке класса, что делает его идеальным для предустановки данных или ресурсов, которые не должны повторно инициализироваться.
        
        ### 4. **Статические вложенные классы** (для структурирования кода)
        
        - **Пример использования**: Когда внутренний класс логически относится к внешнему классу, но не требует доступа к его нестатическим полям или методам.
        - **Часто используется для**: Вспомогательных структур, композиций классов.
        
        **Пример**:
        
        ```java
        java
        Копировать код
        class OuterClass {
            static class NestedStaticClass {
                void printMessage() {
                    System.out.println("Это статический вложенный класс");
                }
            }
        }
        
        public class Main {
            public static void main(String[] args) {
                OuterClass.NestedStaticClass nested = new OuterClass.NestedStaticClass();
                nested.printMessage();
            }
        }
        
        ```
        
        - Статический вложенный класс `NestedStaticClass` существует независимо от объекта внешнего класса `OuterClass`.
        - Статический метод может работать только с статическими переменами
        
        ### 5. **Утилитарные классы** (классы, состоящие только из статических методов)
        
        - **Пример использования**: Когда класс предназначен только для выполнения вспомогательных задач, например, математических расчетов или работы с файлами, без необходимости создания объектов.
        - **Часто используется для**: Утилитарных библиотек, вспомогательных функций.
        
        **Пример**: Класс `java.lang.Math`, где все методы статические, как, например, `Math.sqrt()`, `Math.pow()`, и др.
        
        ### Основные преимущества использования `static`:
        
        - **Экономия памяти**: Статические переменные и методы существуют только в одном экземпляре, поэтому не требуется выделение памяти для каждого объекта.
        - **Удобство вызова**: Статические методы и переменные могут вызываться напрямую через имя класса, что упрощает доступ.
        - **Логическая структура**: Статические члены помогают структурировать код, разделяя общую функциональность от объектно-ориентированной.
        
        Таким образом, `static` в Java используется для создания общей для всех объектов логики и данных, а также для предоставления утилитарных методов, не привязанных к конкретным экземплярам классов.
        
    - `**private**` — члены класса доступны только внутри данного класса;
        
    - **по умолчанию `(package-private)**` — члены класса доступны классам, находящимся в том же пакете; // если используется одинаковый пакет
        
    - **`protected`** — члены класса доступны классам, находящимся в том же пакете, и подклассам(наследование) — в других пакетах;
        
    - **`public`** — члены класса доступны везде.
        
    
    Ключевое слово `final` можно указывать и в объявлении методов. В этом случае оно означает запрет переопределения этого метода в наследнике. Что касается класса, то `final` означает запрет наследования от этого класса. Рассмотрим эти вопросы подробно позже при изучении темы "Наследование".
    
    Подробно про наследование **`protected`**
    
    - **В пределах пакета**: Все классы в одном пакете имеют доступ к `protected` членам, как и с package-private.
    - **В наследниках из любых пакетов**: Подклассы могут обращаться к `protected` членам родительского класса, даже если они находятся в разных пакетах.
    - **Нет доступа для других пакетов**: Классы, которые **не являются наследниками** и находятся в другом пакете, не могут получить доступ к `protected` членам.
    - **Часто используется для наследования**: `protected` модификатор удобен, когда нужно скрыть детали реализации от внешнего мира, но предоставить доступ через наследование.
    
    **`static final`**: Переменная является константой, принадлежащей классу и имеющей неизменяемое значение.
    
    Метод `finalize()` вызывается сборщиком мусора (Garbage Collector) перед тем, как объект будет удален из памяти. Однако, начиная с Java 9, использование этого метода считается устаревшим, так как для очистки ресурсов рекомендуется использовать интерфейсы, такие как `AutoCloseable` в сочетании с конструкцией `try-with-resources`.
    
    @Override - Переопределение метода должно предваряться аннотацией `@Override`. Она указывает компилятору на то, что программист хочет именно переопределить метод, а не создать новый. Поэтому если в заголовке метода будет допущена ошибка (не совпадение с методом суперкласса), компилятор сообщит об этом.
    
    Является конструктором клонирования
    
    public Purchase(Purchase purchase) { [this.name](http://this.name) = [purchase.name](http://purchase.name); this.price = purchase.price; this.weight = purchase.weight; }
    
    Задача по переопределению методов
    
    - Решить
        
        ```java
        public class Purchase {
            private String name;
            private int price;
            private double weight;
            private static final double Nds = 0.2;
        
            public Purchase(String name, int price, double weight) {
                this.name = name;
                this.price = price;
                this.weight = weight;
            }
        
        }
        ```
        
        В классе Main имеем следующий код:
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Purchase p1 = new Purchase("milk",120,1.5);
                Purchase p2 = new Purchase("milk",120,1.5);
                //some code
            }
        }
        ```
        
        Отметьте все варианты кода на месте комментария, которые выведут на консоль true:
        
        ### **Выберите все подходящие ответы из списка**
        
        - [ ] System.out.println(p1.equals(p2));
        - [ ] System.out.println(p1 == p2);
        - [ ] p1 = p2; System.out.println(p1 == p2);
        - [ ] p2 = p1; System.out.println(p1.equals(p2));
        
        пояснение к ответу:
        
        - **System.out.println(p1.equals(p2))** - метод **equals** не переопределён, поэтому сравниваются ссылки;
        - **System.out.println(p1 == p2)** - есть оператор `new`, он создает новый объект в памяти, независимо от того, сколько объектов уже существует с теми же данными. Каждый раз, когда вызывается `new Purchase(...)`, создается новый объект, даже если данные для этого объекта такие же, как и у других объектов
        - `Purchase p1 = new Purchase("milk",120,1.5);`
        - `Purchase p2 = p1;`
        - `System.out.println(p1 == p2);`
        - вернулось бы true, т.к. присваивая `p2 = p1;`, не создаётся новый объект `Purchase`. Вместо этого `p2` просто становится ссылкой, которая указывает на тот же объект, что и `p1`. Оба имени (`p1` и `p2`) ссылались бы на один и тот же объект в памяти.
    
    **Логический блок в классе - это последовательность операторов в фигурных скобках, которая в классе не является частью какого-либо метода. Блок может иметь модификатор static. Обычно блоки используются для инициализации полей класса. Но могут содержать и другие операторы.**
    
    - hasCode() - Метод hashCode() генерирует хеш для объектов, чтобы их легче было сортировать и искать.
        
        Метод `hashCode()` нужен для работы с коллекциями, которые используют **хэш-таблицы** (например, `HashMap`, `HashSet`). Эти коллекции используют хэш-коды, чтобы быстрее искать, добавлять и удалять объекты.
        
        ### Представь, что это адрес для хранения:
        
        - **hashCode()** — это как номер "корзинки" (или ячейки), куда помещается объект.
        - Когда объект добавляется в коллекцию, ему присваивается номер "корзинки" (вычисляется хэш-код). Это ускоряет доступ к объектам.
        
        ### Связь с `equals()`:
        
        - Если два объекта считаются равными по методу `equals()`, они **должны** иметь одинаковый хэш-код.
        - Если не переопределить `hashCode()`, два объекта могут оказаться в разных "корзинках", даже если они равны по `equals()`. Это приведет к ошибкам, когда работаешь с коллекциями, например, могут возникнуть дубликаты.
        
        **Первый вариант предполагает выполнение следующих правил для переопределения `hashCode()` в Java:**
        
        1. Во-первых, необходимо исключить все избыточные поля, которые не участвуют в `equals()`.
        2. Во-вторых, следует выбрать базу — стартовое число, необходимое для расчета hash-кода объекта и присвоить его переменной `total`. Зачастую разработчики берут число 31, но вы можете выбрать иное значение. Многие IDE выполняют генерацию хэш-кода именно с этим числом.
        3. Далее для каждого из оставшихся полей после исключения проводится расчет хэша. Ниже будет приведена таблица правил вычисления для возможных типов полей:
        4. Следующее правило гласит, что нужно прибавить рассчитанный хэш каждого из полей (допустим, это переменная `compute`) к переменной `total`:
        
        ```
        
        total = 31 * total + compute;
        
        ```
        
        **Что запомнить:**
        
        - Hash — это некое число, которое генерируется для объекта, благодаря hash-функциям, в том числе `hashCode()`.
        - Метод `hashCode()` возвращает целочисленное значение hash-кода для выбранного объекта.
        - Если в проекте пользователь планирует использовать ассоциативный массив, а в качестве ключей в нем будут объекты, то метод `hashCode()` рекомендуется переопределять.
        - Правильно подобранная реализация метода `hashCode()` ускорит работу ассоциативных массивов.
        - При переопределении `equals()` нужно не забывать про переопределение `hashCode()`, и наоборот.
        
        ### Как работает в `HashSet`:
        
        1. Когда ты добавляешь объект в `HashSet`, сначала вычисляется его хэш-код.
        2. Коллекция смотрит, есть ли уже что-то в "корзинке" с таким же хэш-кодом.
            - Если корзинка пустая — объект добавляется.
            - Если есть другой объект с таким же хэш-кодом, коллекция проверяет их через `equals()`.
        3. Если объекты равны по `equals()`, второй объект **не добавится**, чтобы избежать дубликатов.
    
    Конструктор клонирование:
    
    ```jsx
    class BusinessTrip {
        private static final int SUM = 25;
        private String name;
        private int trace;
        private int day;
    
        public BusinessTrip(BusinessTrip other) { //Конструктор клонирование
            this(other.name, other.trace, other.day);
        }
    ```
    
    Зачем нужно клонирование:
    
    1)Создание независимой копии объекта - Если вам нужно изменить один объект, но при этом сохранить его исходное состояние, то клонирование позволяет создать его копию и модифицировать эту копию, не затрагивая исходный объект. В нашем случае последний элемент массива командировок должен быть копией первого элемента, но независимо от него.
    
    2)Сохранение оригинала - Иногда вам может потребоваться создать несколько версий одного и того же объекта с небольшими изменениями. В нашем случае, программа требует создания последней командировки как копии первой. Таким образом, изменение фамилии у первой командировки не затрагивает скопированный объект, и обе версии могут использоваться независимо.
    
    Перегрузка - это использование одного имени метода с разными параметрами.Так же часть полиморфизма.
    
    # Варианты перегрузки
    
    Из примеров выше можно выделить три варианта перегрузки.
    
    1. По количеству параметров.
    
    ```
    
    public class Calculator {
      void calculate(int number1, int number2) { }
      void calculate(int number1, int number2, int number3) { }
    }
    ```
    
    2. По типам параметров:
    
    ```
    
    public class Calculator {
      void calculate(int number1, int number2) { }
      void calculate(double number1, double number2) { }
    }
    ```
    
    3. По порядку параметров:
    
    ```
    
    public class Calculator {
      void calculate(double number1, int number2) { }
      void calculate(int number1, double number2) { }
    }
    ```
    
    **Переопределение** метода - метод родительского класса и создать специфическую реализацию в классе-наследнике. пример:Допустим кошка мяукает собака гаф все они издают звук для этого нам надо переопределить метод который отвестен за звук(voice) Даже после переопределения вы можете обратиться к методу родительского класса
    
    Для этого используется ключевое слово super:
    
    ```jsx
    super.method();
    ```
    
    **Ограничения при переопределении**
    
    - Название метода должно быть таким же, как у метода родителя (то есть сигнатура метода должна быть одинаковой).
    - Аргументы должны оставаться такими же, как у метода родителя.
    - Тип возвращаемого значения должен быть таким же, как у метода родителя.
    - Модификатор доступа должен быть таким же, как у метода родителя.
    - Окончательные методы (final) нельзя переопределять. Это один из способов запрета переопределения — объявить метод с помощью ключевого слова final.
    - Статические методы (static) нельзя переопределять. Если вы определите в классе-наследнике такую же сигнатуру метода, как в родительском классе, то выполните сокрытие. Подробнее об этом вы можете прочитать в [документации](https://docs.oracle.com/javase/tutorial/java/IandI/override.html).
    - Приватные методы (private) нельзя переопределять, так как они связываются на этапе компиляции, а не выполнения.
    - Нельзя сужать модификатор доступа — например, с public до private. Расширение уровня доступа возможно.
    - Нельзя менять тип возвращаемого значения, однако можно сузить возвращаемое значение, если они совместимы.
    
    **Последовательность действий системы при создании объект**
    
    - Code
        
        ```jsx
        package Module6;
        
        public class Test15 {
            //нестатический блок
            {
                System.out.println("Логический блок 1");
                System.out.println("a = " + a + " b= " + b + " id= " + this.id + " age= " + this.age);
            }
        
            //статический блок
            static {
                System.out.println("Статический блок 1");
            }
        
            //статические поля
            static int a = 3;
            static int b;
        
            //поля экземпляра
            private int id = 7;
            private int age;
        
            public Test15(int id, int age) {
                this.id = id;
                this.age = age;
                System.out.println("Конструктор");
                System.out.println("a = " + a + " b = " + b + " id = " + this.id + " age = " + this.age);
            }
        
            static void method() { //статический метод
                System.out.println("a = " + a);
                System.out.println("b = " + b);
            }
        
            //статический блок
            static {
                System.out.println("Статический блок 2 начало");
                System.out.println("a = " + a + " b = " + b);
                b = a * 4;
                System.out.println("Статический блок 2 конец");
                System.out.println("a = " + a + " b = " + b);
            }
        
            //нестатический блок - плохое расположение
            {
                System.out.println("Логический блок 2");
                System.out.println("a = " + a + " b = " + b + " id = " + this.id + " age = " + this.age);
            }
        }
        
        ```
        
        результат:
        
        Статический блок 1 Статический блок 2 начало a = 3 b = 0 Статический блок 2 конец a = 3 b = 12 Логический блок 1 a = 3 b= 12 id= 0 age= 0 Логический блок 2 a = 3 b = 12 id = 7 age = 0 Конструктор a = 3 b = 12 id = 1 age = 34
        
        Логический блок 1 a = 3 b= 12 id= 0 age= 0 Логический блок 2 a = 3 b = 12 id = 7 age = 0 Конструктор a = 3 b = 12 id = 2 age = 18
        
    
    В первую очередь идёт выполнение **статических блоков.** потом идёт **обычные не статические блоки, потом коструктор в последнею очередь**. все это сверху вниз выполняется. При повторном вызове статические блоки не вызываются
    
    В канструктор не передаеться статический метод
    
    ## **Основы Наследование**
    
    В Java класс-предок называется _**суперклассом**,_ а класс - потомок – ***подклассом.***Подклассы наследуют элементы суперкласса и добавляют к ним новые элементы (или видоизменяют унаследованные). Таким образом, подклассы осуществляют _**специализацию**_ суперкласса. Общие правила описания подкласса.
    
    _1)    Конструкторы_ не наследуются, поэтому подкласс должен иметь собственные конструкторы. При этом первым действием конструктора подкласса должен быть вызов конструктора его родителя. Правила использования родительского конструктора следующие:
    
    - Если в конструкторе подкласса явный вызов конструктора суперкласса отсутствует, автоматически вызывается конструктор суперкласса без параметров.
    - Если конструктор суперкласса требует указания параметров, он должен быть явным образом вызван **в первой строке** конструктора подкласса. Вызов выполняется с помощью ключевого слова `super`_,_ после которого в скобках указывается список аргументов*.*
    
    _2)  Поля и_ _методы_ суперкласса наследуются.
    
    _3)_  Элементы суперкласса, определенные как `private`, в производном классе недоступны. Поэтому для обращения к private-полям суперкласса нужно использовать геттеры и сеттеры.
    
    4. Слово `super` может означать не только конструктор суперкласса, но и ссылку на любой член суперкласса (поле или метод). Например, `super.toString()` - это обращение к методу `toString()`, который был определен в родительском классе.
    
    5)    Если в подклассе нужно **изменить** поведение метода суперкласса, то его нужно **переопределить**. Для этого достаточно описать метод с той же сигнатурой, которая была использована в суперклассе.
    
    _**Переопределение методов (override)**_ в подклассе выполняется только в том случае, если  _**сигнатуры  обоих методов одинаковы**_ (т.е. одинаковы имена и наборы параметров).
    
    **Динамическая диспетчеризация -** — это механизм в объектно-ориентированном программировании, который позволяет программе решать, какую версию метода (из родительского или дочернего класса) вызвать **во время выполнения**, а не во время компиляции.
    
    Правила что бы этот метод выполнялся без ошибок:
    
    - **Наследование**: Класс, на объекте которого вызывается метод, должен быть потомком (наследником) класса, к которому относится переменная.
        - Например, если переменная типа `Animal` ссылается на объект типа `Dog`, то `Dog` должен наследоваться от `Animal`.
    - **Метод должен быть переопределён**: Метод, который вызывается на объекте, должен быть переопределён в классе-потомке. Иначе будет вызван метод из родительского класса.
        - В классе-потомке можно переопределить метод с той же сигнатурой, чтобы реализовать другую логику для данного класса.
    - **Объявление метода в суперклассе**: Метод, который переопределяется в классе-наследнике, должен быть объявлен в суперклассе.
        - Иначе не будет полиморфизма: суперкласс должен знать о существовании этого метода.
    - **Совпадение сигнатур методов**: Метод в классе-наследнике должен иметь точно такую же сигнатуру (имя, параметры и возвращаемый тип), как и в суперклассе, чтобы метод считался переопределённым.
        - Это важно для корректного вызова метода.
    - **Доступность методов**: Метод должен быть объявлен с модификатором доступа `public` или `protected`, чтобы был доступен в наследуемом классе и мог быть вызван через переменную суперкласса.
    
    Можно вызвать только родительский методы который переопределили в дочернем Пример **Student** student = new **PayerStudent**("Иванов", 8.4, 23, 3500); //**ссылочной переменной суперкласса можно присвоить объект подкласса. в этом и заключается этот метод**
    
    student.calculateScholarship(); //верно так как он переопределён в подклассе student.payment(); //неверно так как его вообще нет в родительском классе
    
    Применение:
    
    **Упрощение кода и расширяемость**: Полиморфизм позволяет работать с объектами разных классов через интерфейсы или суперклассы, не зная их точного типа на этапе компиляции. Это упрощает расширение программы, поскольку можно добавлять новые классы без изменения существующего кода.
    
    **Инкапсуляция изменений**: Если вы изменяете реализацию метода в одном из классов-наследников, то остальной код, использующий суперкласс или интерфейс, не нужно изменять. Таким образом, изменения ограничиваются конкретным классом, что делает код более гибким.
    
    **Использование интерфейсов**: Динамическая диспетчеризация делает возможным использование интерфейсов. Класс может реализовать несколько интерфейсов, и программы могут вызывать методы через эти интерфейсы, не зная конкретного типа объекта.
    
    **Реализация концепции "один интерфейс — много реализаций"**: Полиморфизм позволяет разным классам реализовывать один и тот же метод по-разному. Это мощный способ создавать код, который поддерживает гибкость и масштабируемость.
    
    **Использование в проектировании через абстракции**: Полиморфизм используется при проектировании программ через абстракции, такие как абстрактные классы и интерфейсы. Это позволяет писать более гибкий и масштабируемый код, где реализация может варьироваться, но интерфейс взаимодействия остается одинаковым.
    
    `instanceof` — это оператор в Java, который используется для проверки, является ли объект экземпляром определённого класса или подкласса.
    
    **Абстрактные классы(abstract class) - он помогают организовать код, выделяя общие черты и поведение, которые могут использовать различные подклассы.**
    
    ****Иногда в суперклассе могут быть описаны методы, которые не имеют реализации (тела метода). Эти методы называются абстрактными и служат для того, чтобы просто определить общий функционал всех наследников. При их описании используется модификатор `abstract`
    
    Множественное наследование в java не доступно -
    
    ### 1. **Проблема ромба ("Diamond Problem")**
    
    Если класс наследует несколько классов, в которых есть методы с одинаковыми именами и сигнатурами, возникает ситуация, когда неясно, какую версию метода наследовать. Это называется "проблемой ромба", поскольку граф наследования напоминает форму ромба:
    
    ### 2. **Неопределенность и сложности с управлением**
    
    Множественное наследование усложняет поддержание кода, так как могут возникнуть неоднозначности при вызове методов или доступе к свойствам от разных родительских классов. Это делает код менее предсказуемым и сложным для понимания.
    
    ### 3. **Упрощение и безопасность**
    
    Разработчики Java решили, что множественное наследование может вносить путаницу и усложнять архитектуру приложений. Чтобы упростить разработку и минимизировать ошибки, было решено ограничить наследование одним классом.
    
    ### 4. **Использование интерфейсов как альтернатива**
    
    Вместо множественного наследования Java поддерживает **множественное наследование интерфейсов**. Интерфейсы позволяют классу реализовать несколько наборов методов без риска конфликта реализации. \
    
    ### Заключение
    
    Множественное наследование классов в Java запрещено, чтобы избежать неоднозначностей и сложностей, связанных с проблемой ромба и конфликтами методов, а также для упрощения разработки. Вместо этого Java предлагает интерфейсы, которые позволяют множественное наследование методов без проблем, связанных с реализацией.
    
    Существует три способа использования модификатора `final`:
    
    1. Создание именованной константы.
    2. Предотвращение переопределения методов. Методы, объявленные как `final`, не могут быть переопределены.
    3. Предотвращение наследования. Класс, объявленный как `final`, не может иметь наследников
    
    Интерфейсы — это набор методов без конкретной реализации, которые класс может "пообещать" реализовать. Это как контракт: если класс "подписывается" на интерфейс, он обязуется реализовать все методы, объявленные в этом интерфейсе.
    
    Основная разница между Интерфейсом и Aбстрации - Интерфейсом все методы в нём (за исключением default-методов) **без реализации**. Интерфейс используется, чтобы указать, что класс **должен** обладать определёнными функциями, не связывая его с общей логикой. Абстракция это класс, который может иметь как абстрактные методы (без реализации), так и обычные методы с реализацией. Он используется, когда у разных классов есть общая логика, которую нужно переиспользовать, но есть также методы, которые должны быть реализованы по-разному в каждом конкретном классе.
    
    Наследование Интерфейсом и Aбстрации: Интерфейс может иметь множества наследование(implements) к классу а вот абстракция(extends) только одно.
    
    **Поля/переменные** - **Абстрактный класс**: Может содержать поля (переменные), которые могут хранить состояние или общие для всех классов-наследников данные. **Интерфейс**: Не может иметь состояния (переменных экземпляра), но может иметь константы (по умолчанию переменные интерфейса всегда `public static final`).
    
    Коротко разница Интерфейсом и Aбстрации - абстракция используется когда есть общая логика а интерфейс когда просто задать общие требования к набору методов для разных классов.
    
    Так же есть вложенные интерфейсы.
    
    default - это реализация метода по умолчанию. Но начиная с  Java 8  появилась возможность задавать в интерфейсе реализацию методов по умолчанию. Для этого используется ключевое слово `default` в заголовке метода
    
    **Статические методы в интерфейсах -** обычно используются как вспомогательные (для сортировки, проверок, логирования и т.п.) Они в каком-то смысле  обеспечивают безопасность (т.к. их нельзя переопределить в классе).
    
    **Приватные методы в интерфейсах - Они могут быть статическими и нестатическими, и они обязаны иметь реализацию.**
    
    **Пакеты: Это путь папок в проекте**
    
    **Исключения:**
    
    ![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c232a8ec-53a9-454a-9682-284fb52e1125/f417505e-cd24-483f-ae86-05efd18068d7/image.png)
    
    **Обработка исключений try catch:** Если же в процессе выполнения блока `try` возникает ошибка, то его выполнение прерывается и управление передается подходящему `catch`. Операторы, которые находятся в блоке `try` _**после**_ возникшей ошибки, выполнены _**не будут**_. После завершения работы обработчика программа продолжится с первого оператора, следующего за последним блоком `catch`.
    
    **Генерация исключений:**
    
    _Throwable **throw finally - используется для генерации сообщения после выполнения исключений будет выполнять даже если в предедущийм блоке кода был return**_ Основные правила использование исключений Не создавать класс исключений, эквивалентный по смыслу уже существующему.
    
    Никогда самостоятельно не генерировать **NullPointerException** и избегать случаев, когда такая генерация возможна в принципе.
    
    Не следует в общем случае в секцию `throws` помещать unchecked-исключения (непроверяемые).
    
    Не рекомендуется вкладывать блоки `try-catch` друг в друга из-за ухудшения читаемости кода.
    
    При создании собственных исключений следует проводить наследование от класса **Exception**, либо от другого проверяемого класса исключений, а не от **RuntimeException**.
    
    Никогда не генерировать исключения в инструкции finally.
    
- Глава 8 Алгоритмы
    
    ### 1. **Алгоритмы сортировки**
    
    Эти алгоритмы упорядочивают элементы в массиве или списке.
    
    - **Сортировка пузырьком (Bubble Sort)** — простейший алгоритм, который сравнивает соседние элементы и меняет их местами.
    - **Сортировка выбором (Selection Sort)** — находит минимальный элемент и ставит его на нужное место.
    - **Сортировка вставками (Insertion Sort)** — берет элемент и вставляет его на нужную позицию.
    - **Сортировка слиянием (Merge Sort)** — рекурсивный алгоритм, разделяет массив на части и затем сливает их.
    - **Быстрая сортировка (Quick Sort)** — рекурсивный алгоритм, использует элемент как "опорный" и разбивает массив.
    
    ### 2. **Алгоритмы поиска**
    
    Алгоритмы, которые находят элемент или набор элементов в структуре данных.
    
    - **Линейный поиск (Linear Search)** — последовательный перебор всех элементов.
    - **Бинарный поиск (Binary Search)** — работает на отсортированных данных, делит диапазон поиска пополам.
    
    ### 3. **Алгоритмы работы с графами**
    
    Графовые алгоритмы используются для работы с графами, состоящими из вершин и ребер.
    
    - **Поиск в ширину (BFS, Breadth-First Search)** — исследует все соседние вершины перед переходом к следующему уровню.
    - **Поиск в глубину (DFS, Depth-First Search)** — исследует глубину графа, начиная с одной вершины и углубляясь в нее до конца.
    - **Алгоритм Дейкстры (Dijkstra’s Algorithm)** — находит кратчайший путь от одной вершины до всех других вершин в графе.
    - **Алгоритм Флойда-Уоршелла** — находит кратчайшие пути между всеми парами вершин.
    
    ### 4. **Алгоритмы динамического программирования**
    
    Эти алгоритмы решают задачи, разбивая их на более мелкие подзадачи.
    
    - **Задача о рюкзаке (Knapsack Problem)** — оптимизирует выбор предметов для рюкзака с ограниченной вместимостью.
    - **Алгоритм для поиска наибольшей общей подпоследовательности (LCS, Longest Common Subsequence)** — находит максимальную последовательность, общую для двух строк.
    
    ### 5. **Алгоритмы на строках**
    
    Специализированные алгоритмы для работы с текстом.
    
    - **Алгоритм Кнута-Морриса-Пратта (KMP)** — эффективный алгоритм поиска подстроки.
    - **Алгоритм Бойера-Мура (Boyer-Moore)** — быстрый алгоритм поиска подстрок.
    - **Алгоритм Рабина-Карпа (Rabin-Karp)** — использует хеширование для поиска подстроки.
    
    ### 6. **Жадные алгоритмы**
    
    Жадные алгоритмы строят решение, выбирая на каждом шаге локально оптимальное решение.
    
    - **Алгоритм Краскала (Kruskal’s Algorithm)** — находит минимальное остовное дерево графа.
    - **Алгоритм Прима (Prim’s Algorithm)** — также находит минимальное остовное дерево.
    
    ### 7. **Алгоритмы поиска в пространстве состояний**
    
    Алгоритмы для нахождения решений в задачах поиска путей, оптимальных последовательностей действий.
    
    - **Алгоритм A**— находит кратчайший путь, используя эвристические оценки.
    
    ### 8. **Алгоритмы хеширования**
    
    - **Хеширование** — используется для быстрой проверки принадлежности элемента множеству или быстрого доступа к элементам через ключ.
    
    ### 9. **Алгоритмы теории чисел**
    
    Алгоритмы для работы с числами, их делением и другими арифметическими операциями.
    
    - **Алгоритм Евклида** — находит наибольший общий делитель (НОД) двух чисел.
    - **Решето Эратосфена** — находит все простые числа до заданного числа.
- Архитектура проектирование
    
    [Принципы SOLID](https://www.notion.so/SOLID-a61f020b2d4343dfaba9f7b26cabc337?pvs=21)
    
    [Чистый код. КНИГА](https://www.notion.so/1a0536c9c78880ca8b4cdb91cdc602a7?pvs=21)
